/* automatically generated by rust-bindgen 0.59.2 */

pub const MV_ALG_OK: u32 = 0;
pub const MV_ALG_ERR: u32 = 268435456;
pub const MV_ALG_E_ABILITY_ARG: u32 = 268435457;
pub const MV_ALG_E_MEM_NULL: u32 = 268435458;
pub const MV_ALG_E_MEM_ALIGN: u32 = 268435459;
pub const MV_ALG_E_MEM_LACK: u32 = 268435460;
pub const MV_ALG_E_MEM_SIZE_ALIGN: u32 = 268435461;
pub const MV_ALG_E_MEM_ADDR_ALIGN: u32 = 268435462;
pub const MV_ALG_E_IMG_FORMAT: u32 = 268435463;
pub const MV_ALG_E_IMG_SIZE: u32 = 268435464;
pub const MV_ALG_E_IMG_STEP: u32 = 268435465;
pub const MV_ALG_E_IMG_DATA_NULL: u32 = 268435466;
pub const MV_ALG_E_CFG_TYPE: u32 = 268435467;
pub const MV_ALG_E_CFG_SIZE: u32 = 268435468;
pub const MV_ALG_E_PRC_TYPE: u32 = 268435469;
pub const MV_ALG_E_PRC_SIZE: u32 = 268435470;
pub const MV_ALG_E_FUNC_TYPE: u32 = 268435471;
pub const MV_ALG_E_FUNC_SIZE: u32 = 268435472;
pub const MV_ALG_E_PARAM_INDEX: u32 = 268435473;
pub const MV_ALG_E_PARAM_VALUE: u32 = 268435474;
pub const MV_ALG_E_PARAM_NUM: u32 = 268435475;
pub const MV_ALG_E_NULL_PTR: u32 = 268435476;
pub const MV_ALG_E_OVER_MAX_MEM: u32 = 268435477;
pub const MV_ALG_E_CALL_BACK: u32 = 268435478;
pub const MV_ALG_E_ENCRYPT: u32 = 268435479;
pub const MV_ALG_E_EXPIRE: u32 = 268435480;
pub const MV_ALG_E_BAD_ARG: u32 = 268435481;
pub const MV_ALG_E_DATA_SIZE: u32 = 268435482;
pub const MV_ALG_E_STEP: u32 = 268435483;
pub const MV_ALG_E_CPUID: u32 = 268435484;
pub const MV_ALG_WARNING: u32 = 268435485;
pub const MV_ALG_E_TIME_OUT: u32 = 268435486;
pub const MV_ALG_E_LIB_VERSION: u32 = 268435487;
pub const MV_ALG_E_MODEL_VERSION: u32 = 268435488;
pub const MV_ALG_E_GPU_MEM_ALLOC: u32 = 268435489;
pub const MV_ALG_E_FILE_NON_EXIST: u32 = 268435490;
pub const MV_ALG_E_NONE_STRING: u32 = 268435491;
pub const MV_ALG_E_IMAGE_CODEC: u32 = 268435492;
pub const MV_ALG_E_FILE_OPEN: u32 = 268435493;
pub const MV_ALG_E_FILE_READ: u32 = 268435494;
pub const MV_ALG_E_FILE_WRITE: u32 = 268435495;
pub const MV_ALG_E_FILE_READ_SIZE: u32 = 268435496;
pub const MV_ALG_E_FILE_TYPE: u32 = 268435497;
pub const MV_ALG_E_MODEL_TYPE: u32 = 268435498;
pub const MV_ALG_E_MALLOC_MEM: u32 = 268435499;
pub const MV_ALG_E_BIND_CORE_FAILED: u32 = 268435500;
pub const MV_ALG_E_DENOISE_NE_IMG_FORMAT: u32 = 272637953;
pub const MV_ALG_E_DENOISE_NE_FEATURE_TYPE: u32 = 272637954;
pub const MV_ALG_E_DENOISE_NE_PROFILE_NUM: u32 = 272637955;
pub const MV_ALG_E_DENOISE_NE_GAIN_NUM: u32 = 272637956;
pub const MV_ALG_E_DENOISE_NE_GAIN_VAL: u32 = 272637957;
pub const MV_ALG_E_DENOISE_NE_BIN_NUM: u32 = 272637958;
pub const MV_ALG_E_DENOISE_NE_INIT_GAIN: u32 = 272637959;
pub const MV_ALG_E_DENOISE_NE_NOT_INIT: u32 = 272637960;
pub const MV_ALG_E_DENOISE_COLOR_MODE: u32 = 272637961;
pub const MV_ALG_E_DENOISE_ROI_NUM: u32 = 272637962;
pub const MV_ALG_E_DENOISE_ROI_ORI_PT: u32 = 272637963;
pub const MV_ALG_E_DENOISE_ROI_SIZE: u32 = 272637964;
pub const MV_ALG_E_DENOISE_GAIN_NOT_EXIST: u32 = 272637965;
pub const MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE: u32 = 272637966;
pub const MV_ALG_E_DENOISE_NP_BUF_SIZE: u32 = 272637967;
pub const MV_OK: u32 = 0;
pub const MV_E_HANDLE: u32 = 2147483648;
pub const MV_E_SUPPORT: u32 = 2147483649;
pub const MV_E_BUFOVER: u32 = 2147483650;
pub const MV_E_CALLORDER: u32 = 2147483651;
pub const MV_E_PARAMETER: u32 = 2147483652;
pub const MV_E_RESOURCE: u32 = 2147483654;
pub const MV_E_NODATA: u32 = 2147483655;
pub const MV_E_PRECONDITION: u32 = 2147483656;
pub const MV_E_VERSION: u32 = 2147483657;
pub const MV_E_NOENOUGH_BUF: u32 = 2147483658;
pub const MV_E_ABNORMAL_IMAGE: u32 = 2147483659;
pub const MV_E_LOAD_LIBRARY: u32 = 2147483660;
pub const MV_E_NOOUTBUF: u32 = 2147483661;
pub const MV_E_ENCRYPT: u32 = 2147483662;
pub const MV_E_UNKNOW: u32 = 2147483903;
pub const MV_E_GC_GENERIC: u32 = 2147483904;
pub const MV_E_GC_ARGUMENT: u32 = 2147483905;
pub const MV_E_GC_RANGE: u32 = 2147483906;
pub const MV_E_GC_PROPERTY: u32 = 2147483907;
pub const MV_E_GC_RUNTIME: u32 = 2147483908;
pub const MV_E_GC_LOGICAL: u32 = 2147483909;
pub const MV_E_GC_ACCESS: u32 = 2147483910;
pub const MV_E_GC_TIMEOUT: u32 = 2147483911;
pub const MV_E_GC_DYNAMICCAST: u32 = 2147483912;
pub const MV_E_GC_UNKNOW: u32 = 2147484159;
pub const MV_E_NOT_IMPLEMENTED: u32 = 2147484160;
pub const MV_E_INVALID_ADDRESS: u32 = 2147484161;
pub const MV_E_WRITE_PROTECT: u32 = 2147484162;
pub const MV_E_ACCESS_DENIED: u32 = 2147484163;
pub const MV_E_BUSY: u32 = 2147484164;
pub const MV_E_PACKET: u32 = 2147484165;
pub const MV_E_NETER: u32 = 2147484166;
pub const MV_E_IP_CONFLICT: u32 = 2147484193;
pub const MV_E_USB_READ: u32 = 2147484416;
pub const MV_E_USB_WRITE: u32 = 2147484417;
pub const MV_E_USB_DEVICE: u32 = 2147484418;
pub const MV_E_USB_GENICAM: u32 = 2147484419;
pub const MV_E_USB_BANDWIDTH: u32 = 2147484420;
pub const MV_E_USB_DRIVER: u32 = 2147484421;
pub const MV_E_USB_UNKNOW: u32 = 2147484671;
pub const MV_E_UPG_FILE_MISMATCH: u32 = 2147484672;
pub const MV_E_UPG_LANGUSGE_MISMATCH: u32 = 2147484673;
pub const MV_E_UPG_CONFLICT: u32 = 2147484674;
pub const MV_E_UPG_INNER_ERR: u32 = 2147484675;
pub const MV_E_UPG_UNKNOW: u32 = 2147484927;
pub const MV_GVSP_PIX_MONO: u32 = 16777216;
pub const MV_GVSP_PIX_RGB: u32 = 33554432;
pub const MV_GVSP_PIX_COLOR: u32 = 33554432;
pub const MV_GVSP_PIX_CUSTOM: u32 = 2147483648;
pub const MV_GVSP_PIX_COLOR_MASK: u32 = 4278190080;
pub const MV_GVSP_PIX_EFFECTIVE_PIXEL_SIZE_MASK: u32 = 16711680;
pub const MV_GVSP_PIX_EFFECTIVE_PIXEL_SIZE_SHIFT: u32 = 16;
pub const MV_GVSP_PIX_ID_MASK: u32 = 65535;
pub const MV_GVSP_PIX_COUNT: u32 = 70;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const INFO_MAX_BUFFER_SIZE: u32 = 64;
pub const MV_UNKNOW_DEVICE: u32 = 0;
pub const MV_GIGE_DEVICE: u32 = 1;
pub const MV_1394_DEVICE: u32 = 2;
pub const MV_USB_DEVICE: u32 = 4;
pub const MV_CAMERALINK_DEVICE: u32 = 8;
pub const MV_MAX_TLS_NUM: u32 = 8;
pub const MV_MAX_DEVICE_NUM: u32 = 256;
pub const MV_MAX_GENTL_IF_NUM: u32 = 256;
pub const MV_MAX_GENTL_DEV_NUM: u32 = 256;
pub const MV_ACCESS_Exclusive: u32 = 1;
pub const MV_ACCESS_ExclusiveWithSwitch: u32 = 2;
pub const MV_ACCESS_Control: u32 = 3;
pub const MV_ACCESS_ControlWithSwitch: u32 = 4;
pub const MV_ACCESS_ControlSwitchEnable: u32 = 5;
pub const MV_ACCESS_ControlSwitchEnableWithKey: u32 = 6;
pub const MV_ACCESS_Monitor: u32 = 7;
pub const MV_MATCH_TYPE_NET_DETECT: u32 = 1;
pub const MV_MATCH_TYPE_USB_DETECT: u32 = 2;
pub const MV_IP_CFG_STATIC: u32 = 83886080;
pub const MV_IP_CFG_DHCP: u32 = 100663296;
pub const MV_IP_CFG_LLA: u32 = 67108864;
pub const MV_NET_TRANS_DRIVER: u32 = 1;
pub const MV_NET_TRANS_SOCKET: u32 = 2;
pub const MV_CAML_BAUDRATE_9600: u32 = 1;
pub const MV_CAML_BAUDRATE_19200: u32 = 2;
pub const MV_CAML_BAUDRATE_38400: u32 = 4;
pub const MV_CAML_BAUDRATE_57600: u32 = 8;
pub const MV_CAML_BAUDRATE_115200: u32 = 16;
pub const MV_CAML_BAUDRATE_230400: u32 = 32;
pub const MV_CAML_BAUDRATE_460800: u32 = 64;
pub const MV_CAML_BAUDRATE_921600: u32 = 128;
pub const MV_CAML_BAUDRATE_AUTOMAX: u32 = 1073741824;
pub const MV_EXCEPTION_DEV_DISCONNECT: u32 = 32769;
pub const MV_EXCEPTION_VERSION_CHECK: u32 = 32770;
pub const MAX_EVENT_NAME_SIZE: u32 = 128;
pub const MV_MAX_XML_SYMBOLIC_NUM: u32 = 64;
pub const MV_MAX_XML_NODE_NUM_C: u32 = 128;
pub const MV_MAX_XML_NODE_STRLEN_C: u32 = 64;
pub const MV_MAX_XML_STRVALUE_STRLEN_C: u32 = 64;
pub const MV_MAX_XML_DISC_STRLEN_C: u32 = 512;
pub const MV_MAX_XML_ENTRY_NUM: u32 = 10;
pub const MV_MAX_XML_PARENTS_NUM: u32 = 8;
pub const MV_MAX_XML_SYMBOLIC_STRLEN_C: u32 = 64;
pub const MvGvspPixelType_PixelType_Gvsp_Undefined: MvGvspPixelType = -1;
pub const MvGvspPixelType_PixelType_Gvsp_Mono1p: MvGvspPixelType = 16842807;
pub const MvGvspPixelType_PixelType_Gvsp_Mono2p: MvGvspPixelType = 16908344;
pub const MvGvspPixelType_PixelType_Gvsp_Mono4p: MvGvspPixelType = 17039417;
pub const MvGvspPixelType_PixelType_Gvsp_Mono8: MvGvspPixelType = 17301505;
pub const MvGvspPixelType_PixelType_Gvsp_Mono8_Signed: MvGvspPixelType = 17301506;
pub const MvGvspPixelType_PixelType_Gvsp_Mono10: MvGvspPixelType = 17825795;
pub const MvGvspPixelType_PixelType_Gvsp_Mono10_Packed: MvGvspPixelType = 17563652;
pub const MvGvspPixelType_PixelType_Gvsp_Mono12: MvGvspPixelType = 17825797;
pub const MvGvspPixelType_PixelType_Gvsp_Mono12_Packed: MvGvspPixelType = 17563654;
pub const MvGvspPixelType_PixelType_Gvsp_Mono14: MvGvspPixelType = 17825829;
pub const MvGvspPixelType_PixelType_Gvsp_Mono16: MvGvspPixelType = 17825799;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGR8: MvGvspPixelType = 17301512;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRG8: MvGvspPixelType = 17301513;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGB8: MvGvspPixelType = 17301514;
pub const MvGvspPixelType_PixelType_Gvsp_BayerBG8: MvGvspPixelType = 17301515;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRBGG8: MvGvspPixelType = 17301574;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGR10: MvGvspPixelType = 17825804;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRG10: MvGvspPixelType = 17825805;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGB10: MvGvspPixelType = 17825806;
pub const MvGvspPixelType_PixelType_Gvsp_BayerBG10: MvGvspPixelType = 17825807;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGR12: MvGvspPixelType = 17825808;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRG12: MvGvspPixelType = 17825809;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGB12: MvGvspPixelType = 17825810;
pub const MvGvspPixelType_PixelType_Gvsp_BayerBG12: MvGvspPixelType = 17825811;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGR10_Packed: MvGvspPixelType = 17563686;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRG10_Packed: MvGvspPixelType = 17563687;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGB10_Packed: MvGvspPixelType = 17563688;
pub const MvGvspPixelType_PixelType_Gvsp_BayerBG10_Packed: MvGvspPixelType = 17563689;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGR12_Packed: MvGvspPixelType = 17563690;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRG12_Packed: MvGvspPixelType = 17563691;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGB12_Packed: MvGvspPixelType = 17563692;
pub const MvGvspPixelType_PixelType_Gvsp_BayerBG12_Packed: MvGvspPixelType = 17563693;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGR16: MvGvspPixelType = 17825838;
pub const MvGvspPixelType_PixelType_Gvsp_BayerRG16: MvGvspPixelType = 17825839;
pub const MvGvspPixelType_PixelType_Gvsp_BayerGB16: MvGvspPixelType = 17825840;
pub const MvGvspPixelType_PixelType_Gvsp_BayerBG16: MvGvspPixelType = 17825841;
pub const MvGvspPixelType_PixelType_Gvsp_RGB8_Packed: MvGvspPixelType = 35127316;
pub const MvGvspPixelType_PixelType_Gvsp_BGR8_Packed: MvGvspPixelType = 35127317;
pub const MvGvspPixelType_PixelType_Gvsp_RGBA8_Packed: MvGvspPixelType = 35651606;
pub const MvGvspPixelType_PixelType_Gvsp_BGRA8_Packed: MvGvspPixelType = 35651607;
pub const MvGvspPixelType_PixelType_Gvsp_RGB10_Packed: MvGvspPixelType = 36700184;
pub const MvGvspPixelType_PixelType_Gvsp_BGR10_Packed: MvGvspPixelType = 36700185;
pub const MvGvspPixelType_PixelType_Gvsp_RGB12_Packed: MvGvspPixelType = 36700186;
pub const MvGvspPixelType_PixelType_Gvsp_BGR12_Packed: MvGvspPixelType = 36700187;
pub const MvGvspPixelType_PixelType_Gvsp_RGB16_Packed: MvGvspPixelType = 36700211;
pub const MvGvspPixelType_PixelType_Gvsp_BGR16_Packed: MvGvspPixelType = 36700235;
pub const MvGvspPixelType_PixelType_Gvsp_RGBA16_Packed: MvGvspPixelType = 37748836;
pub const MvGvspPixelType_PixelType_Gvsp_BGRA16_Packed: MvGvspPixelType = 37748817;
pub const MvGvspPixelType_PixelType_Gvsp_RGB10V1_Packed: MvGvspPixelType = 35651612;
pub const MvGvspPixelType_PixelType_Gvsp_RGB10V2_Packed: MvGvspPixelType = 35651613;
pub const MvGvspPixelType_PixelType_Gvsp_RGB12V1_Packed: MvGvspPixelType = 35913780;
pub const MvGvspPixelType_PixelType_Gvsp_RGB565_Packed: MvGvspPixelType = 34603061;
pub const MvGvspPixelType_PixelType_Gvsp_BGR565_Packed: MvGvspPixelType = 34603062;
pub const MvGvspPixelType_PixelType_Gvsp_YUV411_Packed: MvGvspPixelType = 34340894;
pub const MvGvspPixelType_PixelType_Gvsp_YUV422_Packed: MvGvspPixelType = 34603039;
pub const MvGvspPixelType_PixelType_Gvsp_YUV422_YUYV_Packed: MvGvspPixelType = 34603058;
pub const MvGvspPixelType_PixelType_Gvsp_YUV444_Packed: MvGvspPixelType = 35127328;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR8_CBYCR: MvGvspPixelType = 35127354;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR422_8: MvGvspPixelType = 34603067;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR422_8_CBYCRY: MvGvspPixelType = 34603075;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR411_8_CBYYCRYY: MvGvspPixelType = 34340924;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR601_8_CBYCR: MvGvspPixelType = 35127357;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR601_422_8: MvGvspPixelType = 34603070;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR601_422_8_CBYCRY: MvGvspPixelType = 34603076;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY: MvGvspPixelType = 34340927;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR709_8_CBYCR: MvGvspPixelType = 35127360;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR709_422_8: MvGvspPixelType = 34603073;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR709_422_8_CBYCRY: MvGvspPixelType = 34603077;
pub const MvGvspPixelType_PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY: MvGvspPixelType = 34340930;
pub const MvGvspPixelType_PixelType_Gvsp_RGB8_Planar: MvGvspPixelType = 35127329;
pub const MvGvspPixelType_PixelType_Gvsp_RGB10_Planar: MvGvspPixelType = 36700194;
pub const MvGvspPixelType_PixelType_Gvsp_RGB12_Planar: MvGvspPixelType = 36700195;
pub const MvGvspPixelType_PixelType_Gvsp_RGB16_Planar: MvGvspPixelType = 36700196;
pub const MvGvspPixelType_PixelType_Gvsp_Jpeg: MvGvspPixelType = -2145910783;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_ABC32f: MvGvspPixelType = 39846080;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_ABC32f_Planar: MvGvspPixelType = 39846081;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_AC32f: MvGvspPixelType = 36176066;
pub const MvGvspPixelType_PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK: MvGvspPixelType = -2112094207;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_ABC32: MvGvspPixelType = -2107625471;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_AB32f: MvGvspPixelType = -2109722622;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_AB32: MvGvspPixelType = -2109722621;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_AC32f_64: MvGvspPixelType = 37748930;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_AC32f_Planar: MvGvspPixelType = 37748931;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_AC32: MvGvspPixelType = -2109722620;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_A32f: MvGvspPixelType = 18874557;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_A32: MvGvspPixelType = -2128596987;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_C32f: MvGvspPixelType = 18874559;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_C32: MvGvspPixelType = -2128596986;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_ABC16: MvGvspPixelType = 36700345;
pub const MvGvspPixelType_PixelType_Gvsp_Coord3D_C16: MvGvspPixelType = 17825976;
pub const MvGvspPixelType_PixelType_Gvsp_HB_Mono8: MvGvspPixelType = -2130182143;
pub const MvGvspPixelType_PixelType_Gvsp_HB_Mono10: MvGvspPixelType = -2129657853;
pub const MvGvspPixelType_PixelType_Gvsp_HB_Mono10_Packed: MvGvspPixelType = -2129919996;
pub const MvGvspPixelType_PixelType_Gvsp_HB_Mono12: MvGvspPixelType = -2129657851;
pub const MvGvspPixelType_PixelType_Gvsp_HB_Mono12_Packed: MvGvspPixelType = -2129919994;
pub const MvGvspPixelType_PixelType_Gvsp_HB_Mono16: MvGvspPixelType = -2129657849;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGR8: MvGvspPixelType = -2130182136;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerRG8: MvGvspPixelType = -2130182135;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGB8: MvGvspPixelType = -2130182134;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerBG8: MvGvspPixelType = -2130182133;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerRBGG8: MvGvspPixelType = -2130182074;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGR10: MvGvspPixelType = -2129657844;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerRG10: MvGvspPixelType = -2129657843;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGB10: MvGvspPixelType = -2129657842;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerBG10: MvGvspPixelType = -2129657841;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGR12: MvGvspPixelType = -2129657840;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerRG12: MvGvspPixelType = -2129657839;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGB12: MvGvspPixelType = -2129657838;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerBG12: MvGvspPixelType = -2129657837;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGR10_Packed: MvGvspPixelType = -2129919962;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerRG10_Packed: MvGvspPixelType = -2129919961;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGB10_Packed: MvGvspPixelType = -2129919960;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerBG10_Packed: MvGvspPixelType = -2129919959;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGR12_Packed: MvGvspPixelType = -2129919958;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerRG12_Packed: MvGvspPixelType = -2129919957;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerGB12_Packed: MvGvspPixelType = -2129919956;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BayerBG12_Packed: MvGvspPixelType = -2129919955;
pub const MvGvspPixelType_PixelType_Gvsp_HB_YUV422_Packed: MvGvspPixelType = -2112880609;
pub const MvGvspPixelType_PixelType_Gvsp_HB_YUV422_YUYV_Packed: MvGvspPixelType = -2112880590;
pub const MvGvspPixelType_PixelType_Gvsp_HB_RGB8_Packed: MvGvspPixelType = -2112356332;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BGR8_Packed: MvGvspPixelType = -2112356331;
pub const MvGvspPixelType_PixelType_Gvsp_HB_RGBA8_Packed: MvGvspPixelType = -2111832042;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BGRA8_Packed: MvGvspPixelType = -2111832041;
pub const MvGvspPixelType_PixelType_Gvsp_HB_RGB16_Packed: MvGvspPixelType = -2110783437;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BGR16_Packed: MvGvspPixelType = -2110783413;
pub const MvGvspPixelType_PixelType_Gvsp_HB_RGBA16_Packed: MvGvspPixelType = -2109734812;
pub const MvGvspPixelType_PixelType_Gvsp_HB_BGRA16_Packed: MvGvspPixelType = -2109734831;
pub type MvGvspPixelType = ::std::os::raw::c_int;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type bool_ = ::std::os::raw::c_char;
#[doc = " \\~chinese GigE设备信息              \\~english GigE device info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_GIGE_DEVICE_INFO_ {
    #[doc = "< [OUT] \\~chinese IP配置选项             \\~english IP Configuration Options"]
    pub nIpCfgOption: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 当前IP配置             \\~english IP Configuration"]
    pub nIpCfgCurrent: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 当前IP地址             \\~english Current Ip"]
    pub nCurrentIp: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 当前子网掩码           \\~english Curtent Subnet Mask"]
    pub nCurrentSubNetMask: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 当前网关               \\~english Current Gateway"]
    pub nDefultGateWay: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 制造商名称             \\~english Manufacturer Name"]
    pub chManufacturerName: [::std::os::raw::c_uchar; 32usize],
    #[doc = "< [OUT] \\~chinese 型号名称               \\~english Model Name"]
    pub chModelName: [::std::os::raw::c_uchar; 32usize],
    #[doc = "< [OUT] \\~chinese 设备版本               \\~english Device Version"]
    pub chDeviceVersion: [::std::os::raw::c_uchar; 32usize],
    #[doc = "< [OUT] \\~chinese 制造商的具体信息       \\~english Manufacturer Specific Information"]
    pub chManufacturerSpecificInfo: [::std::os::raw::c_uchar; 48usize],
    #[doc = "< [OUT] \\~chinese 序列号                 \\~english Serial Number"]
    pub chSerialNumber: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< [OUT] \\~chinese 用户自定义名称         \\~english User Defined Name"]
    pub chUserDefinedName: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< [OUT] \\~chinese 网口IP地址             \\~english NetWork IP Address"]
    pub nNetExport: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_GIGE_DEVICE_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_GIGE_DEVICE_INFO_>(),
        216usize,
        concat!("Size of: ", stringify!(_MV_GIGE_DEVICE_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_GIGE_DEVICE_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_GIGE_DEVICE_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nIpCfgOption as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nIpCfgOption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nIpCfgCurrent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nIpCfgCurrent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nCurrentIp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nCurrentIp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nCurrentSubNetMask as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nCurrentSubNetMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nDefultGateWay as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nDefultGateWay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).chManufacturerName as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(chManufacturerName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).chModelName as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(chModelName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).chDeviceVersion as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(chDeviceVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).chManufacturerSpecificInfo as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(chManufacturerSpecificInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).chSerialNumber as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(chSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).chUserDefinedName as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(chUserDefinedName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nNetExport as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nNetExport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GIGE_DEVICE_INFO_>())).nReserved as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GIGE_DEVICE_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese GigE设备信息              \\~english GigE device info"]
pub type MV_GIGE_DEVICE_INFO = _MV_GIGE_DEVICE_INFO_;
#[doc = " \\~chinese USB设备信息               \\~english USB device info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_USB3_DEVICE_INFO_ {
    #[doc = "< [OUT] \\~chinese 控制输入端点           \\~english Control input endpoint"]
    pub CrtlInEndPoint: ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 控制输出端点           \\~english Control output endpoint"]
    pub CrtlOutEndPoint: ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 流端点                 \\~english Flow endpoint"]
    pub StreamEndPoint: ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 事件端点               \\~english Event endpoint"]
    pub EventEndPoint: ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 供应商ID号             \\~english Vendor ID Number"]
    pub idVendor: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 产品ID号               \\~english Device ID Number"]
    pub idProduct: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 设备索引号             \\~english Device Number"]
    pub nDeviceNumber: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 设备GUID号             \\~english Device GUID Number"]
    pub chDeviceGUID: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 供应商名字             \\~english Vendor Name"]
    pub chVendorName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 型号名字               \\~english Model Name"]
    pub chModelName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 家族名字               \\~english Family Name"]
    pub chFamilyName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 设备版本               \\~english Device Version"]
    pub chDeviceVersion: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 制造商名字             \\~english Manufacturer Name"]
    pub chManufacturerName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 序列号                 \\~english Serial Number"]
    pub chSerialNumber: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 用户自定义名字         \\~english User Defined Name"]
    pub chUserDefinedName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 支持的USB协议          \\~english Support USB Protocol"]
    pub nbcdUSB: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 设备地址               \\~english Device Address"]
    pub nDeviceAddress: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout__MV_USB3_DEVICE_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_USB3_DEVICE_INFO_>(),
        540usize,
        concat!("Size of: ", stringify!(_MV_USB3_DEVICE_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_USB3_DEVICE_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_USB3_DEVICE_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).CrtlInEndPoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(CrtlInEndPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).CrtlOutEndPoint as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(CrtlOutEndPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).StreamEndPoint as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(StreamEndPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).EventEndPoint as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(EventEndPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).idVendor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).idProduct as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).nDeviceNumber as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(nDeviceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chDeviceGUID as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chDeviceGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chVendorName as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chVendorName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chModelName as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chModelName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chFamilyName as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chFamilyName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chDeviceVersion as *const _ as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chDeviceVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chManufacturerName as *const _
                as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chManufacturerName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chSerialNumber as *const _ as usize
        },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).chUserDefinedName as *const _ as usize
        },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(chUserDefinedName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).nbcdUSB as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(nbcdUSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).nDeviceAddress as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(nDeviceAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_USB3_DEVICE_INFO_>())).nReserved as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_USB3_DEVICE_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese USB设备信息               \\~english USB device info"]
pub type MV_USB3_DEVICE_INFO = _MV_USB3_DEVICE_INFO_;
#[doc = " \\~chinese CameraLink设备信息        \\~english CameraLink device info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CamL_DEV_INFO_ {
    #[doc = "< [OUT] \\~chinese 端口号                 \\~english Port ID"]
    pub chPortID: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 型号名字               \\~english Model Name"]
    pub chModelName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 名称                   \\~english Family Name"]
    pub chFamilyName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 设备版本               \\~english Device Version"]
    pub chDeviceVersion: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 制造商名字             \\~english Manufacturer Name"]
    pub chManufacturerName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 序列号                 \\~english Serial Number"]
    pub chSerialNumber: [::std::os::raw::c_uchar; 64usize],
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 38usize],
}
#[test]
fn bindgen_test_layout__MV_CamL_DEV_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CamL_DEV_INFO_>(),
        536usize,
        concat!("Size of: ", stringify!(_MV_CamL_DEV_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CamL_DEV_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_CamL_DEV_INFO_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).chPortID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(chPortID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).chModelName as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(chModelName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).chFamilyName as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(chFamilyName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).chDeviceVersion as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(chDeviceVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).chManufacturerName as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(chManufacturerName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).chSerialNumber as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(chSerialNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CamL_DEV_INFO_>())).nReserved as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CamL_DEV_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese CameraLink设备信息        \\~english CameraLink device info"]
pub type MV_CamL_DEV_INFO = _MV_CamL_DEV_INFO_;
#[doc = " \\~chinese 设备信息                  \\~english Device info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MV_CC_DEVICE_INFO_ {
    #[doc = "< [OUT] \\~chinese 主要版本               \\~english Major Version"]
    pub nMajorVer: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 次要版本               \\~english Minor Version"]
    pub nMinorVer: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 高MAC地址              \\~english High MAC Address"]
    pub nMacAddrHigh: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 低MAC地址              \\~english Low MAC Address"]
    pub nMacAddrLow: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 设备传输层协议类型     \\~english Device Transport Layer Protocol Type"]
    pub nTLayerType: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 4usize],
    pub SpecialInfo: _MV_CC_DEVICE_INFO___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MV_CC_DEVICE_INFO___bindgen_ty_1 {
    #[doc = "< [OUT] \\~chinese GigE设备信息           \\~english GigE Device Info"]
    pub stGigEInfo: MV_GIGE_DEVICE_INFO,
    #[doc = "< [OUT] \\~chinese USB设备信息            \\~english USB Device Info"]
    pub stUsb3VInfo: MV_USB3_DEVICE_INFO,
    #[doc = "< [OUT] \\~chinese CameraLink设备信息     \\~english CameraLink Device Info"]
    pub stCamLInfo: MV_CamL_DEV_INFO,
}
#[test]
fn bindgen_test_layout__MV_CC_DEVICE_INFO___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_DEVICE_INFO___bindgen_ty_1>(),
        540usize,
        concat!("Size of: ", stringify!(_MV_CC_DEVICE_INFO___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_DEVICE_INFO___bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_MV_CC_DEVICE_INFO___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO___bindgen_ty_1>())).stGigEInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO___bindgen_ty_1),
            "::",
            stringify!(stGigEInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO___bindgen_ty_1>())).stUsb3VInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO___bindgen_ty_1),
            "::",
            stringify!(stUsb3VInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO___bindgen_ty_1>())).stCamLInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO___bindgen_ty_1),
            "::",
            stringify!(stCamLInfo)
        )
    );
}
#[test]
fn bindgen_test_layout__MV_CC_DEVICE_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_DEVICE_INFO_>(),
        572usize,
        concat!("Size of: ", stringify!(_MV_CC_DEVICE_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_DEVICE_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_CC_DEVICE_INFO_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).nMajorVer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(nMajorVer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).nMinorVer as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(nMinorVer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).nMacAddrHigh as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(nMacAddrHigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).nMacAddrLow as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(nMacAddrLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).nTLayerType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(nTLayerType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).nReserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_>())).SpecialInfo as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_),
            "::",
            stringify!(SpecialInfo)
        )
    );
}
#[doc = " \\~chinese 设备信息                  \\~english Device info"]
pub type MV_CC_DEVICE_INFO = _MV_CC_DEVICE_INFO_;
#[doc = " \\~chinese 设备信息列表              \\~english Device Information List"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_DEVICE_INFO_LIST_ {
    #[doc = "< [OUT] \\~chinese 在线设备数量           \\~english Online Device Number"]
    pub nDeviceNum: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 支持最多256个设备      \\~english Support up to 256 devices"]
    pub pDeviceInfo: [*mut MV_CC_DEVICE_INFO; 256usize],
}
#[test]
fn bindgen_test_layout__MV_CC_DEVICE_INFO_LIST_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_DEVICE_INFO_LIST_>(),
        2056usize,
        concat!("Size of: ", stringify!(_MV_CC_DEVICE_INFO_LIST_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_DEVICE_INFO_LIST_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_DEVICE_INFO_LIST_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_LIST_>())).nDeviceNum as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_LIST_),
            "::",
            stringify!(nDeviceNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_DEVICE_INFO_LIST_>())).pDeviceInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_DEVICE_INFO_LIST_),
            "::",
            stringify!(pDeviceInfo)
        )
    );
}
#[doc = " \\~chinese 设备信息列表              \\~english Device Information List"]
pub type MV_CC_DEVICE_INFO_LIST = _MV_CC_DEVICE_INFO_LIST_;
#[doc = " \\~chinese 通过GenTL枚举到的接口信息 \\~english Interface Information with GenTL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_GENTL_IF_INFO_ {
    #[doc = "< [OUT] \\~chinese GenTL接口ID            \\~english Interface ID"]
    pub chInterfaceID: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 传输层类型             \\~english GenTL Type"]
    pub chTLType: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese Interface显示名称      \\~english Display Name"]
    pub chDisplayName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese GenTL的cti文件索引     \\~english The Index of Cti Files"]
    pub nCtiIndex: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_GENTL_IF_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_GENTL_IF_INFO_>(),
        228usize,
        concat!("Size of: ", stringify!(_MV_GENTL_IF_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_GENTL_IF_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_GENTL_IF_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_>())).chInterfaceID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_),
            "::",
            stringify!(chInterfaceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_>())).chTLType as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_),
            "::",
            stringify!(chTLType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_>())).chDisplayName as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_),
            "::",
            stringify!(chDisplayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_>())).nCtiIndex as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_),
            "::",
            stringify!(nCtiIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_>())).nReserved as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 通过GenTL枚举到的接口信息 \\~english Interface Information with GenTL"]
pub type MV_GENTL_IF_INFO = _MV_GENTL_IF_INFO_;
#[doc = " \\~chinese 通过GenTL枚举到的接口信息列表 \\~english Inferface Information List with GenTL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_GENTL_IF_INFO_LIST_ {
    #[doc = "< [OUT] \\~chinese 在线接口数量           \\~english Online Inferface Number"]
    pub nInterfaceNum: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 支持最多256个接口      \\~english Support up to 256 inferfaces"]
    pub pIFInfo: [*mut MV_GENTL_IF_INFO; 256usize],
}
#[test]
fn bindgen_test_layout__MV_GENTL_IF_INFO_LIST_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_GENTL_IF_INFO_LIST_>(),
        2056usize,
        concat!("Size of: ", stringify!(_MV_GENTL_IF_INFO_LIST_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_GENTL_IF_INFO_LIST_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_GENTL_IF_INFO_LIST_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_LIST_>())).nInterfaceNum as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_LIST_),
            "::",
            stringify!(nInterfaceNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_IF_INFO_LIST_>())).pIFInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_IF_INFO_LIST_),
            "::",
            stringify!(pIFInfo)
        )
    );
}
#[doc = " \\~chinese 通过GenTL枚举到的接口信息列表 \\~english Inferface Information List with GenTL"]
pub type MV_GENTL_IF_INFO_LIST = _MV_GENTL_IF_INFO_LIST_;
#[doc = " \\~chinese 通过GenTL枚举到的设备信息 \\~english Device Information with GenTL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_GENTL_DEV_INFO_ {
    #[doc = "< [OUT] \\~chinese GenTL接口ID            \\~english Interface ID"]
    pub chInterfaceID: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 设备ID                 \\~english Device ID"]
    pub chDeviceID: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 供应商名字             \\~english Vendor Name"]
    pub chVendorName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 型号名字               \\~english Model Name"]
    pub chModelName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 传输层类型             \\~english GenTL Type"]
    pub chTLType: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 设备显示名称           \\~english Display Name"]
    pub chDisplayName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 用户自定义名字         \\~english User Defined Name"]
    pub chUserDefinedName: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 序列号                 \\~english Serial Number"]
    pub chSerialNumber: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese 设备版本号             \\~english Device Version"]
    pub chDeviceVersion: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< [OUT] \\~chinese GenTL的cti文件索引     \\~english The Index of Cti Files"]
    pub nCtiIndex: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_GENTL_DEV_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_GENTL_DEV_INFO_>(),
        612usize,
        concat!("Size of: ", stringify!(_MV_GENTL_DEV_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_GENTL_DEV_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_GENTL_DEV_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chInterfaceID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chInterfaceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chDeviceID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chDeviceID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chVendorName as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chVendorName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chModelName as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chModelName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chTLType as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chTLType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chDisplayName as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chUserDefinedName as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chUserDefinedName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chSerialNumber as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).chDeviceVersion as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(chDeviceVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).nCtiIndex as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(nCtiIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_>())).nReserved as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 通过GenTL枚举到的设备信息 \\~english Device Information with GenTL"]
pub type MV_GENTL_DEV_INFO = _MV_GENTL_DEV_INFO_;
#[doc = " \\~chinese 通过GenTL枚举到的设备信息列表 \\~english Device Information List with GenTL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_GENTL_DEV_INFO_LIST_ {
    #[doc = "< [OUT] \\~chinese 在线设备数量           \\~english Online Device Number"]
    pub nDeviceNum: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 支持最多256个设备      \\~english Support up to 256 devices"]
    pub pDeviceInfo: [*mut MV_GENTL_DEV_INFO; 256usize],
}
#[test]
fn bindgen_test_layout__MV_GENTL_DEV_INFO_LIST_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_GENTL_DEV_INFO_LIST_>(),
        2056usize,
        concat!("Size of: ", stringify!(_MV_GENTL_DEV_INFO_LIST_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_GENTL_DEV_INFO_LIST_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_GENTL_DEV_INFO_LIST_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_LIST_>())).nDeviceNum as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_LIST_),
            "::",
            stringify!(nDeviceNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_GENTL_DEV_INFO_LIST_>())).pDeviceInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_GENTL_DEV_INFO_LIST_),
            "::",
            stringify!(pDeviceInfo)
        )
    );
}
#[doc = " \\~chinese 通过GenTL枚举到的设备信息列表 \\~english Device Information List with GenTL"]
pub type MV_GENTL_DEV_INFO_LIST = _MV_GENTL_DEV_INFO_LIST_;
#[doc = " \\~chinese Chunk内容                 \\~english The content of ChunkData"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CHUNK_DATA_CONTENT_ {
    #[doc = "< [OUT] \\~chinese Chunk数据              \\~english Chunk Data"]
    pub pChunkData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese Chunk ID               \\~english Chunk ID"]
    pub nChunkID: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese Chunk的长度            \\~english Chunk Length"]
    pub nChunkLen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CHUNK_DATA_CONTENT_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CHUNK_DATA_CONTENT_>(),
        48usize,
        concat!("Size of: ", stringify!(_MV_CHUNK_DATA_CONTENT_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CHUNK_DATA_CONTENT_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CHUNK_DATA_CONTENT_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CHUNK_DATA_CONTENT_>())).pChunkData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CHUNK_DATA_CONTENT_),
            "::",
            stringify!(pChunkData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CHUNK_DATA_CONTENT_>())).nChunkID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CHUNK_DATA_CONTENT_),
            "::",
            stringify!(nChunkID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CHUNK_DATA_CONTENT_>())).nChunkLen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CHUNK_DATA_CONTENT_),
            "::",
            stringify!(nChunkLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CHUNK_DATA_CONTENT_>())).nReserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CHUNK_DATA_CONTENT_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese Chunk内容                 \\~english The content of ChunkData"]
pub type MV_CHUNK_DATA_CONTENT = _MV_CHUNK_DATA_CONTENT_;
#[doc = " \\~chinese 输出帧的信息              \\~english Output Frame Information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MV_FRAME_OUT_INFO_EX_ {
    #[doc = "< [OUT] \\~chinese 图像宽                 \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 图像高                 \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 像素格式               \\~english Pixel Type"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [OUT] \\~chinese 帧号                   \\~english Frame Number"]
    pub nFrameNum: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 时间戳高32位           \\~english Timestamp high 32 bits"]
    pub nDevTimeStampHigh: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 时间戳低32位           \\~english Timestamp low 32 bits"]
    pub nDevTimeStampLow: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 保留，8字节对齐        \\~english Reserved, 8-byte aligned"]
    pub nReserved0: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 主机生成的时间戳       \\~english Host-generated timestamp"]
    pub nHostTimeStamp: i64,
    #[doc = "< [OUT] \\~chinese 帧的长度               \\~english The Length of Frame"]
    pub nFrameLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 秒数                   \\~english The Seconds"]
    pub nSecondCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 周期数                 \\~english The Count of Cycle"]
    pub nCycleCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 周期偏移量             \\~english The Offset of Cycle"]
    pub nCycleOffset: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 增益                   \\~english Gain"]
    pub fGain: f32,
    #[doc = "< [OUT] \\~chinese 曝光时间               \\~english Exposure Time"]
    pub fExposureTime: f32,
    #[doc = "< [OUT] \\~chinese 平均亮度               \\~english Average brightness"]
    pub nAverageBrightness: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 红色                   \\~english Red"]
    pub nRed: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 绿色                   \\~english Green"]
    pub nGreen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 蓝色                   \\~english Blue"]
    pub nBlue: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 总帧数                 \\~english Frame Counter"]
    pub nFrameCounter: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 触发计数               \\~english Trigger Counting"]
    pub nTriggerIndex: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输入                   \\~english Input"]
    pub nInput: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出                   \\~english Output"]
    pub nOutput: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 水平偏移量             \\~english OffsetX"]
    pub nOffsetX: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 垂直偏移量             \\~english OffsetY"]
    pub nOffsetY: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese Chunk宽                \\~english The Width of Chunk"]
    pub nChunkWidth: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese Chunk高                \\~english The Height of Chunk"]
    pub nChunkHeight: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 本帧丢包数             \\~english Lost Packet Number In This Frame"]
    pub nLostPacket: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 未解析的Chunkdata个数  \\~english Unparsed Chunk Number"]
    pub nUnparsedChunkNum: ::std::os::raw::c_uint,
    pub UnparsedChunkList: _MV_FRAME_OUT_INFO_EX___bindgen_ty_1,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 36usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MV_FRAME_OUT_INFO_EX___bindgen_ty_1 {
    #[doc = "< [OUT] \\~chinese 未解析的Chunk          \\~english Unparsed Chunk Content"]
    pub pUnparsedChunkContent: *mut MV_CHUNK_DATA_CONTENT,
    #[doc = "< [OUT] \\~chinese 校准                   \\~english Aligning"]
    pub nAligning: i64,
}
#[test]
fn bindgen_test_layout__MV_FRAME_OUT_INFO_EX___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_MV_FRAME_OUT_INFO_EX___bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_MV_FRAME_OUT_INFO_EX___bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_FRAME_OUT_INFO_EX___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MV_FRAME_OUT_INFO_EX___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX___bindgen_ty_1>())).pUnparsedChunkContent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX___bindgen_ty_1),
            "::",
            stringify!(pUnparsedChunkContent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX___bindgen_ty_1>())).nAligning as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX___bindgen_ty_1),
            "::",
            stringify!(nAligning)
        )
    );
}
#[test]
fn bindgen_test_layout__MV_FRAME_OUT_INFO_EX_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_FRAME_OUT_INFO_EX_>(),
        256usize,
        concat!("Size of: ", stringify!(_MV_FRAME_OUT_INFO_EX_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_FRAME_OUT_INFO_EX_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_FRAME_OUT_INFO_EX_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nHeight as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).enPixelType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nFrameNum as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nFrameNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nDevTimeStampHigh as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nDevTimeStampHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nDevTimeStampLow as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nDevTimeStampLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nReserved0 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nReserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nHostTimeStamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nHostTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nFrameLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nFrameLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nSecondCount as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nSecondCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nCycleCount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nCycleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nCycleOffset as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nCycleOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).fGain as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(fGain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).fExposureTime as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(fExposureTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nAverageBrightness as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nAverageBrightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nRed as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nRed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nGreen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nGreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nBlue as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nBlue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nFrameCounter as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nFrameCounter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nTriggerIndex as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nTriggerIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nInput as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nOutput as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nOutput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nOffsetX as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nOffsetX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nOffsetY as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nOffsetY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nChunkWidth as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nChunkWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nChunkHeight as *const _ as usize
        },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nChunkHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nLostPacket as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nLostPacket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nUnparsedChunkNum as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nUnparsedChunkNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).UnparsedChunkList as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(UnparsedChunkList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_EX_>())).nReserved as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_EX_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 输出帧的信息              \\~english Output Frame Information"]
pub type MV_FRAME_OUT_INFO_EX = _MV_FRAME_OUT_INFO_EX_;
#[doc = " \\~chinese 图像结构体，输出图像地址及图像信息    \\~english Image Struct, output the pointer of Image and the information of the specific image"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MV_FRAME_OUT_ {
    #[doc = "< [OUT] \\~chinese 图像指针地址           \\~english  pointer of image"]
    pub pBufAddr: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 图像信息               \\~english information of the specific image"]
    pub stFrameInfo: MV_FRAME_OUT_INFO_EX,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout__MV_FRAME_OUT_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_FRAME_OUT_>(),
        328usize,
        concat!("Size of: ", stringify!(_MV_FRAME_OUT_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_FRAME_OUT_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_FRAME_OUT_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_>())).pBufAddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_),
            "::",
            stringify!(pBufAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_>())).stFrameInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_),
            "::",
            stringify!(stFrameInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_>())).nRes as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 图像结构体，输出图像地址及图像信息    \\~english Image Struct, output the pointer of Image and the information of the specific image"]
pub type MV_FRAME_OUT = _MV_FRAME_OUT_;
#[doc = "< \\~chinese 从旧到新一帧一帧的获取图像   \\~english Grab One By One"]
pub const _MV_GRAB_STRATEGY__MV_GrabStrategy_OneByOne: _MV_GRAB_STRATEGY_ = 0;
#[doc = "< \\~chinese 获取列表中最新的一帧图像     \\~english Grab The Latest Image"]
pub const _MV_GRAB_STRATEGY__MV_GrabStrategy_LatestImagesOnly: _MV_GRAB_STRATEGY_ = 1;
#[doc = "< \\~chinese 获取列表中最新的图像         \\~english Grab The Latest Images"]
pub const _MV_GRAB_STRATEGY__MV_GrabStrategy_LatestImages: _MV_GRAB_STRATEGY_ = 2;
#[doc = "< \\~chinese 等待下一帧图像               \\~english Grab The Upcoming Image"]
pub const _MV_GRAB_STRATEGY__MV_GrabStrategy_UpcomingImage: _MV_GRAB_STRATEGY_ = 3;
#[doc = " \\~chinese 取流策略                  \\~english The strategy of Grabbing"]
pub type _MV_GRAB_STRATEGY_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 取流策略                  \\~english The strategy of Grabbing"]
pub use self::_MV_GRAB_STRATEGY_ as MV_GRAB_STRATEGY;
#[doc = " \\~chinese 网络传输的相关信息        \\~english Network transmission information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_NETTRANS_INFO_ {
    #[doc = "< [OUT] \\~chinese 已接收数据大小[Start和Stop之间]    \\~english Received Data Size"]
    pub nReceiveDataSize: i64,
    #[doc = "< [OUT] \\~chinese 丢帧数量                           \\~english Throw frame number"]
    pub nThrowFrameCount: ::std::os::raw::c_int,
    #[doc = "< [OUT] \\~chinese 已接收的帧数                       \\~english Received Frame Count"]
    pub nNetRecvFrameCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 请求重发包数                       \\~english Request Resend Packet Count"]
    pub nRequestResendPacketCount: i64,
    #[doc = "< [OUT] \\~chinese 重发包数                           \\~english Resend Packet Count"]
    pub nResendPacketCount: i64,
}
#[test]
fn bindgen_test_layout__MV_NETTRANS_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_NETTRANS_INFO_>(),
        32usize,
        concat!("Size of: ", stringify!(_MV_NETTRANS_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_NETTRANS_INFO_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_NETTRANS_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_NETTRANS_INFO_>())).nReceiveDataSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_NETTRANS_INFO_),
            "::",
            stringify!(nReceiveDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_NETTRANS_INFO_>())).nThrowFrameCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_NETTRANS_INFO_),
            "::",
            stringify!(nThrowFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_NETTRANS_INFO_>())).nNetRecvFrameCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_NETTRANS_INFO_),
            "::",
            stringify!(nNetRecvFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_NETTRANS_INFO_>())).nRequestResendPacketCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_NETTRANS_INFO_),
            "::",
            stringify!(nRequestResendPacketCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_NETTRANS_INFO_>())).nResendPacketCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_NETTRANS_INFO_),
            "::",
            stringify!(nResendPacketCount)
        )
    );
}
#[doc = " \\~chinese 网络传输的相关信息        \\~english Network transmission information"]
pub type MV_NETTRANS_INFO = _MV_NETTRANS_INFO_;
#[doc = " \\~chinese 全匹配的一种信息结构体    \\~english A fully matched information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_ALL_MATCH_INFO_ {
    #[doc = "< [IN]  \\~chinese 需要输出的信息类型，e.g. MV_MATCH_TYPE_NET_DETECT  \\~english Information type need to output ,e.g. MV_MATCH_TYPE_NET_DETECT"]
    pub nType: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出的信息缓存，由调用者分配                       \\~english Output information cache, which is allocated by the caller"]
    pub pInfo: *mut ::std::os::raw::c_void,
    #[doc = "< [IN]  \\~chinese 信息缓存的大小                                     \\~english Information cache size"]
    pub nInfoSize: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__MV_ALL_MATCH_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_ALL_MATCH_INFO_>(),
        24usize,
        concat!("Size of: ", stringify!(_MV_ALL_MATCH_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_ALL_MATCH_INFO_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_ALL_MATCH_INFO_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ALL_MATCH_INFO_>())).nType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ALL_MATCH_INFO_),
            "::",
            stringify!(nType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ALL_MATCH_INFO_>())).pInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ALL_MATCH_INFO_),
            "::",
            stringify!(pInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ALL_MATCH_INFO_>())).nInfoSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ALL_MATCH_INFO_),
            "::",
            stringify!(nInfoSize)
        )
    );
}
#[doc = " \\~chinese 全匹配的一种信息结构体    \\~english A fully matched information structure"]
pub type MV_ALL_MATCH_INFO = _MV_ALL_MATCH_INFO_;
#[doc = " \\~chinese 网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT     \\~english Network traffic and packet loss feedback structure, the corresponding type is MV_MATCH_TYPE_NET_DETECT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_MATCH_INFO_NET_DETECT_ {
    #[doc = "< [OUT] \\~chinese 已接收数据大小[Start和Stop之间]    \\~english Received data size"]
    pub nReceiveDataSize: i64,
    #[doc = "< [OUT] \\~chinese 丢失的包数量                       \\~english Number of packets lost"]
    pub nLostPacketCount: i64,
    #[doc = "< [OUT] \\~chinese 丢帧数量                           \\~english Number of frames lost"]
    pub nLostFrameCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 保留                               \\~english Received Frame Count"]
    pub nNetRecvFrameCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 请求重发包数                       \\~english Request Resend Packet Count"]
    pub nRequestResendPacketCount: i64,
    #[doc = "< [OUT] \\~chinese 重发包数                           \\~english Resend Packet Count"]
    pub nResendPacketCount: i64,
}
#[test]
fn bindgen_test_layout__MV_MATCH_INFO_NET_DETECT_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_MATCH_INFO_NET_DETECT_>(),
        40usize,
        concat!("Size of: ", stringify!(_MV_MATCH_INFO_NET_DETECT_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_MATCH_INFO_NET_DETECT_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_MATCH_INFO_NET_DETECT_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_NET_DETECT_>())).nReceiveDataSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_NET_DETECT_),
            "::",
            stringify!(nReceiveDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_NET_DETECT_>())).nLostPacketCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_NET_DETECT_),
            "::",
            stringify!(nLostPacketCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_NET_DETECT_>())).nLostFrameCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_NET_DETECT_),
            "::",
            stringify!(nLostFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_NET_DETECT_>())).nNetRecvFrameCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_NET_DETECT_),
            "::",
            stringify!(nNetRecvFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_NET_DETECT_>())).nRequestResendPacketCount
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_NET_DETECT_),
            "::",
            stringify!(nRequestResendPacketCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_NET_DETECT_>())).nResendPacketCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_NET_DETECT_),
            "::",
            stringify!(nResendPacketCount)
        )
    );
}
#[doc = " \\~chinese 网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT     \\~english Network traffic and packet loss feedback structure, the corresponding type is MV_MATCH_TYPE_NET_DETECT"]
pub type MV_MATCH_INFO_NET_DETECT = _MV_MATCH_INFO_NET_DETECT_;
#[doc = " \\~chinese host收到从u3v设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT    \\~english The total number of bytes host received from the u3v device side, the corresponding type is MV_MATCH_TYPE_USB_DETECT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_MATCH_INFO_USB_DETECT_ {
    #[doc = "< [OUT] \\~chinese 已接收数据大小 [Open和Close之间]   \\~english Received data size"]
    pub nReceiveDataSize: i64,
    #[doc = "< [OUT] \\~chinese 已收到的帧数                       \\~english Number of frames received"]
    pub nReceivedFrameCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 错误帧数                           \\~english Number of error frames"]
    pub nErrorFrameCount: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 保留                               \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout__MV_MATCH_INFO_USB_DETECT_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_MATCH_INFO_USB_DETECT_>(),
        24usize,
        concat!("Size of: ", stringify!(_MV_MATCH_INFO_USB_DETECT_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_MATCH_INFO_USB_DETECT_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_MATCH_INFO_USB_DETECT_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_USB_DETECT_>())).nReceiveDataSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_USB_DETECT_),
            "::",
            stringify!(nReceiveDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_USB_DETECT_>())).nReceivedFrameCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_USB_DETECT_),
            "::",
            stringify!(nReceivedFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_USB_DETECT_>())).nErrorFrameCount as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_USB_DETECT_),
            "::",
            stringify!(nErrorFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_MATCH_INFO_USB_DETECT_>())).nReserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_MATCH_INFO_USB_DETECT_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese host收到从u3v设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT    \\~english The total number of bytes host received from the u3v device side, the corresponding type is MV_MATCH_TYPE_USB_DETECT"]
pub type MV_MATCH_INFO_USB_DETECT = _MV_MATCH_INFO_USB_DETECT_;
#[doc = " \\~chinese 显示帧信息                \\~english Display frame information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_DISPLAY_FRAME_INFO_ {
    #[doc = "< [IN] \\~chinese 窗口句柄                \\~english HWND"]
    pub hWnd: *mut ::std::os::raw::c_void,
    #[doc = "< [IN] \\~chinese 显示的数据              \\~english Data Buffer"]
    pub pData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN] \\~chinese 数据长度                \\~english Data Size"]
    pub nDataLen: ::std::os::raw::c_uint,
    #[doc = "< [IN] \\~chinese 图像宽                  \\~english Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [IN] \\~chinese 图像高                  \\~english Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [IN] \\~chinese 像素格式                \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "<      \\~chinese 保留                    \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_DISPLAY_FRAME_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_DISPLAY_FRAME_INFO_>(),
        48usize,
        concat!("Size of: ", stringify!(_MV_DISPLAY_FRAME_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_DISPLAY_FRAME_INFO_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_DISPLAY_FRAME_INFO_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).hWnd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(hWnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).nDataLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(nDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).nWidth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).nHeight as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).enPixelType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_DISPLAY_FRAME_INFO_>())).nRes as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_DISPLAY_FRAME_INFO_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 显示帧信息                \\~english Display frame information"]
pub type MV_DISPLAY_FRAME_INFO = _MV_DISPLAY_FRAME_INFO_;
#[doc = "< \\~chinese 未定义的点云格式             \\~english Undefined point cloud format"]
pub const MV_SAVE_POINT_CLOUD_FILE_TYPE_MV_PointCloudFile_Undefined: MV_SAVE_POINT_CLOUD_FILE_TYPE =
    0;
#[doc = "< \\~chinese PLY点云格式                  \\~english The point cloud format named PLY"]
pub const MV_SAVE_POINT_CLOUD_FILE_TYPE_MV_PointCloudFile_PLY: MV_SAVE_POINT_CLOUD_FILE_TYPE = 1;
#[doc = "< \\~chinese CSV点云格式                  \\~english The point cloud format named CSV"]
pub const MV_SAVE_POINT_CLOUD_FILE_TYPE_MV_PointCloudFile_CSV: MV_SAVE_POINT_CLOUD_FILE_TYPE = 2;
#[doc = "< \\~chinese OBJ点云格式                  \\~english The point cloud format named OBJ"]
pub const MV_SAVE_POINT_CLOUD_FILE_TYPE_MV_PointCloudFile_OBJ: MV_SAVE_POINT_CLOUD_FILE_TYPE = 3;
#[doc = " \\~chinese 保存的3D数据格式          \\~english The saved format for 3D data"]
pub type MV_SAVE_POINT_CLOUD_FILE_TYPE = ::std::os::raw::c_int;
#[doc = " \\~chinese 保存3D数据到缓存          \\~english Save 3D data to buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_SAVE_POINT_CLOUD_PARAM_ {
    #[doc = "< [IN]  \\~chinese 行点数，即图像宽       \\~english The number of points in each row,which is the width of the image"]
    pub nLinePntNum: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 行数，即图像高         \\~english The number of rows,which is the height of the image"]
    pub nLineNum: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据的像素格式     \\~english The pixel format of the input data"]
    pub enSrcPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input data length"]
    pub nSrcDataLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出像素数据缓存       \\~english Output pixel data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小(nLinePntNum * nLineNum * (16*3 + 4) + 2048)   \\~english Output buffer size provided(nLinePntNum * nLineNum * (16*3 + 4) + 2048)"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出像素数据缓存长度   \\~english Output pixel data buffer size"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 提供输出的点云文件类型 \\~english Output point data file type provided"]
    pub enPointCloudFileType: MV_SAVE_POINT_CLOUD_FILE_TYPE,
    #[doc = "<       \\~chinese 保留字段               \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_SAVE_POINT_CLOUD_PARAM_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_SAVE_POINT_CLOUD_PARAM_>(),
        88usize,
        concat!("Size of: ", stringify!(_MV_SAVE_POINT_CLOUD_PARAM_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_SAVE_POINT_CLOUD_PARAM_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_SAVE_POINT_CLOUD_PARAM_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).nLinePntNum as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(nLinePntNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).nLineNum as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(nLineNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).enSrcPixelType as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(enSrcPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).pSrcData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(pSrcData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).nSrcDataLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(nSrcDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).pDstBuf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).nDstBufSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).nDstBufLen as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).enPointCloudFileType as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(enPointCloudFileType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_POINT_CLOUD_PARAM_>())).nReserved as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_POINT_CLOUD_PARAM_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 保存3D数据到缓存          \\~english Save 3D data to buffer"]
pub type MV_SAVE_POINT_CLOUD_PARAM = _MV_SAVE_POINT_CLOUD_PARAM_;
#[doc = "< \\~chinese 未定义的图像格式             \\~english Undefined Image Type"]
pub const MV_SAVE_IAMGE_TYPE_MV_Image_Undefined: MV_SAVE_IAMGE_TYPE = 0;
#[doc = "< \\~chinese BMP图像格式                  \\~english BMP Image Type"]
pub const MV_SAVE_IAMGE_TYPE_MV_Image_Bmp: MV_SAVE_IAMGE_TYPE = 1;
#[doc = "< \\~chinese JPEG图像格式                 \\~english Jpeg Image Type"]
pub const MV_SAVE_IAMGE_TYPE_MV_Image_Jpeg: MV_SAVE_IAMGE_TYPE = 2;
#[doc = "< \\~chinese PNG图像格式                  \\~english Png  Image Type"]
pub const MV_SAVE_IAMGE_TYPE_MV_Image_Png: MV_SAVE_IAMGE_TYPE = 3;
#[doc = "< \\~chinese TIFF图像格式                 \\~english TIFF Image Type"]
pub const MV_SAVE_IAMGE_TYPE_MV_Image_Tif: MV_SAVE_IAMGE_TYPE = 4;
#[doc = " \\~chinese 保存图片格式              \\~english Save image type"]
pub type MV_SAVE_IAMGE_TYPE = ::std::os::raw::c_int;
#[doc = " \\~chinese 图片保存参数              \\~english Save Image Parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_SAVE_IMAGE_PARAM_T_EX_ {
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input Data Buffer"]
    pub pData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input Data length"]
    pub nDataLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据的像素格式     \\~english Input Data Pixel Format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 图像宽                 \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 图像高                 \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 输出图片缓存           \\~english Output Image Buffer"]
    pub pImageBuffer: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 输出图片长度           \\~english Output Image length"]
    pub nImageLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Output buffer size provided"]
    pub nBufferSize: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输出图片格式           \\~english Output Image Format"]
    pub enImageType: MV_SAVE_IAMGE_TYPE,
    #[doc = "< [IN]  \\~chinese JPG编码质量(50-99]，其它格式无效   \\~english Encoding quality(50-99]，Other formats are invalid"]
    pub nJpgQuality: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 插值方法 0-快速 1-均衡 2-最优（其它值默认为最优）  \\~english Bayer interpolation method  0-Fast 1-Equilibrium 2-Optimal"]
    pub iMethodValue: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout__MV_SAVE_IMAGE_PARAM_T_EX_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_SAVE_IMAGE_PARAM_T_EX_>(),
        64usize,
        concat!("Size of: ", stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_SAVE_IMAGE_PARAM_T_EX_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).pData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nDataLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).enPixelType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nWidth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nHeight as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).pImageBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(pImageBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nImageLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nImageLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nBufferSize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).enImageType as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(enImageType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nJpgQuality as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nJpgQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).iMethodValue as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(iMethodValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_EX_>())).nReserved as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_EX_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 图片保存参数              \\~english Save Image Parameters"]
pub type MV_SAVE_IMAGE_PARAM_EX = _MV_SAVE_IMAGE_PARAM_T_EX_;
#[doc = " \\~chinese 图片保存参数              \\~english Save Image Parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_SAVE_IMG_TO_FILE_PARAM_ {
    #[doc = "< [IN]  \\~chinese输入数据的像素格式      \\~english The pixel format of the input data"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input Data Buffer"]
    pub pData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input Data length"]
    pub nDataLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像宽                 \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 图像高                 \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 输入图片格式           \\~english Input Image Format"]
    pub enImageType: MV_SAVE_IAMGE_TYPE,
    #[doc = "< [IN]  \\~chinese JPG编码质量(50-99]，PNG编码质量[0-9]，其它格式无效 \\~english JPG Encoding quality(50-99],PNG Encoding quality[0-9]，Other formats are invalid"]
    pub nQuality: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入文件路径           \\~english Input file path"]
    pub pImagePath: [::std::os::raw::c_char; 256usize],
    #[doc = "< [IN]  \\~chinese 插值方法 0-快速 1-均衡 2-最优（其它值默认为最优）  \\~english Bayer interpolation method  0-Fast 1-Equilibrium 2-Optimal"]
    pub iMethodValue: ::std::os::raw::c_int,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_SAVE_IMG_TO_FILE_PARAM_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_SAVE_IMG_TO_FILE_PARAM_>(),
        328usize,
        concat!("Size of: ", stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_SAVE_IMG_TO_FILE_PARAM_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).enPixelType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).pData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).nDataLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(nDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).nWidth as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).nHeight as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).enImageType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(enImageType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).nQuality as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(nQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).pImagePath as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(pImagePath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).iMethodValue as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(iMethodValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMG_TO_FILE_PARAM_>())).nReserved as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMG_TO_FILE_PARAM_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 图片保存参数              \\~english Save Image Parameters"]
pub type MV_SAVE_IMG_TO_FILE_PARAM = _MV_SAVE_IMG_TO_FILE_PARAM_;
pub const _MV_IMG_ROTATION_ANGLE__MV_IMAGE_ROTATE_90: _MV_IMG_ROTATION_ANGLE_ = 1;
pub const _MV_IMG_ROTATION_ANGLE__MV_IMAGE_ROTATE_180: _MV_IMG_ROTATION_ANGLE_ = 2;
pub const _MV_IMG_ROTATION_ANGLE__MV_IMAGE_ROTATE_270: _MV_IMG_ROTATION_ANGLE_ = 3;
#[doc = " \\~chinese 旋转角度                  \\~english Rotation angle"]
pub type _MV_IMG_ROTATION_ANGLE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 旋转角度                  \\~english Rotation angle"]
pub use self::_MV_IMG_ROTATION_ANGLE_ as MV_IMG_ROTATION_ANGLE;
#[doc = " \\~chinese 图像旋转结构体            \\~english Rotate image structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_ROTATE_IMAGE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN][OUT] \\~chinese 图像宽             \\~english Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN][OUT] \\~chinese 图像高             \\~english Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input data length"]
    pub nSrcDataLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 旋转角度               \\~english Rotation angle"]
    pub enRotationAngle: MV_IMG_ROTATION_ANGLE,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_ROTATE_IMAGE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_ROTATE_IMAGE_PARAM_T_>(),
        88usize,
        concat!("Size of: ", stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_ROTATE_IMAGE_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).enPixelType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).nWidth as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).nHeight as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).pSrcData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(pSrcData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).nSrcDataLen as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(nSrcDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).nDstBufLen as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).nDstBufSize as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).enRotationAngle as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(enRotationAngle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_ROTATE_IMAGE_PARAM_T_>())).nRes as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_ROTATE_IMAGE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 图像旋转结构体            \\~english Rotate image structure"]
pub type MV_CC_ROTATE_IMAGE_PARAM = _MV_CC_ROTATE_IMAGE_PARAM_T_;
pub const _MV_IMG_FLIP_TYPE__MV_FLIP_VERTICAL: _MV_IMG_FLIP_TYPE_ = 1;
pub const _MV_IMG_FLIP_TYPE__MV_FLIP_HORIZONTAL: _MV_IMG_FLIP_TYPE_ = 2;
#[doc = " \\~chinese 翻转类型                  \\~english Flip type"]
pub type _MV_IMG_FLIP_TYPE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 翻转类型                  \\~english Flip type"]
pub use self::_MV_IMG_FLIP_TYPE_ as MV_IMG_FLIP_TYPE;
#[doc = " \\~chinese 图像翻转结构体            \\~english Flip image structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_FLIP_IMAGE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 图像宽                 \\~english Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高                 \\~english Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input data length"]
    pub nSrcDataLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 翻转类型               \\~english Flip type"]
    pub enFlipType: MV_IMG_FLIP_TYPE,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_FLIP_IMAGE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_FLIP_IMAGE_PARAM_T_>(),
        88usize,
        concat!("Size of: ", stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_FLIP_IMAGE_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).enPixelType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).nWidth as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).nHeight as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).pSrcData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(pSrcData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).nSrcDataLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(nSrcDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).nDstBufLen as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).nDstBufSize as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).enFlipType as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(enFlipType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FLIP_IMAGE_PARAM_T_>())).nRes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FLIP_IMAGE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 图像翻转结构体            \\~english Flip image structure"]
pub type MV_CC_FLIP_IMAGE_PARAM = _MV_CC_FLIP_IMAGE_PARAM_T_;
#[doc = " \\~chinese 像素转换结构体            \\~english Pixel convert structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_PIXEL_CONVERT_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽                 \\~english Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 图像高                 \\~english Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 源像素格式             \\~english Source pixel format"]
    pub enSrcPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input data length"]
    pub nSrcDataLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 目标像素格式           \\~english Destination pixel format"]
    pub enDstPixelType: MvGvspPixelType,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuffer: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufferSize: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_PIXEL_CONVERT_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_PIXEL_CONVERT_PARAM_T_>(),
        56usize,
        concat!("Size of: ", stringify!(_MV_PIXEL_CONVERT_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_PIXEL_CONVERT_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_PIXEL_CONVERT_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).nWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).nHeight as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).enSrcPixelType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(enSrcPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).pSrcData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(pSrcData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).nSrcDataLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(nSrcDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).enDstPixelType as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(enDstPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).pDstBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(pDstBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).nDstLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(nDstLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).nDstBufferSize as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(nDstBufferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_PIXEL_CONVERT_PARAM_T_>())).nRes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_PIXEL_CONVERT_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 像素转换结构体            \\~english Pixel convert structure"]
pub type MV_CC_PIXEL_CONVERT_PARAM = _MV_PIXEL_CONVERT_PARAM_T_;
#[doc = "< \\~chinese 不启用                       \\~english Disable"]
pub const _MV_CC_GAMMA_TYPE__MV_CC_GAMMA_TYPE_NONE: _MV_CC_GAMMA_TYPE_ = 0;
#[doc = "< \\~chinese Gamma值                      \\~english Gamma value"]
pub const _MV_CC_GAMMA_TYPE__MV_CC_GAMMA_TYPE_VALUE: _MV_CC_GAMMA_TYPE_ = 1;
#[doc = "< \\~chinese Gamma曲线                    \\~english Gamma curve"]
#[doc = "< \\~chinese 8位,长度：256*sizeof(unsigned char)      \\~english 8bit,length:256*sizeof(unsigned char)"]
#[doc = "< \\~chinese 10位,长度：1024*sizeof(unsigned short)   \\~english 10bit,length:1024*sizeof(unsigned short)"]
#[doc = "< \\~chinese 12位,长度：4096*sizeof(unsigned short)   \\~english 12bit,length:4096*sizeof(unsigned short)"]
#[doc = "< \\~chinese 16位,长度：65536*sizeof(unsigned short)  \\~english 16bit,length:65536*sizeof(unsigned short)"]
pub const _MV_CC_GAMMA_TYPE__MV_CC_GAMMA_TYPE_USER_CURVE: _MV_CC_GAMMA_TYPE_ = 2;
#[doc = "< \\~chinese linear RGB to sRGB           \\~english linear RGB to sRGB"]
pub const _MV_CC_GAMMA_TYPE__MV_CC_GAMMA_TYPE_LRGB2SRGB: _MV_CC_GAMMA_TYPE_ = 3;
#[doc = "< \\~chinese sRGB to linear RGB(仅色彩插值时支持，色彩校正时无效) \\~english sRGB to linear RGB"]
pub const _MV_CC_GAMMA_TYPE__MV_CC_GAMMA_TYPE_SRGB2LRGB: _MV_CC_GAMMA_TYPE_ = 4;
#[doc = " \\~chinese Gamma类型                 \\~english Gamma type"]
pub type _MV_CC_GAMMA_TYPE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese Gamma类型                 \\~english Gamma type"]
pub use self::_MV_CC_GAMMA_TYPE_ as MV_CC_GAMMA_TYPE;
#[doc = " \\~chinese Gamma信息结构体           \\~english Gamma info structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_GAMMA_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese Gamma类型              \\~english Gamma type"]
    pub enGammaType: MV_CC_GAMMA_TYPE,
    #[doc = "< [IN]  \\~chinese Gamma值[0.1,4.0]       \\~english Gamma value[0.1,4.0]"]
    pub fGammaValue: f32,
    #[doc = "< [IN]  \\~chinese Gamma曲线缓存          \\~english Gamma curve buffer"]
    pub pGammaCurveBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese Gamma曲线长度          \\~english Gamma curve buffer size"]
    pub nGammaCurveBufLen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_GAMMA_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_GAMMA_PARAM_T_>(),
        56usize,
        concat!("Size of: ", stringify!(_MV_CC_GAMMA_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_GAMMA_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_GAMMA_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_GAMMA_PARAM_T_>())).enGammaType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_GAMMA_PARAM_T_),
            "::",
            stringify!(enGammaType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_GAMMA_PARAM_T_>())).fGammaValue as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_GAMMA_PARAM_T_),
            "::",
            stringify!(fGammaValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_GAMMA_PARAM_T_>())).pGammaCurveBuf as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_GAMMA_PARAM_T_),
            "::",
            stringify!(pGammaCurveBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_GAMMA_PARAM_T_>())).nGammaCurveBufLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_GAMMA_PARAM_T_),
            "::",
            stringify!(nGammaCurveBufLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_GAMMA_PARAM_T_>())).nRes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_GAMMA_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese Gamma信息结构体           \\~english Gamma info structure"]
pub type MV_CC_GAMMA_PARAM = _MV_CC_GAMMA_PARAM_T_;
#[doc = " \\~chinese CCM参数                   \\~english CCM param"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_CCM_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 是否启用CCM            \\~english CCM enable"]
    pub bCCMEnable: bool_,
    #[doc = "< [IN]  \\~chinese CCM矩阵(-8192~8192)    \\~english Color correction matrix(-8192~8192)"]
    pub nCCMat: [::std::os::raw::c_int; 9usize],
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_CCM_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_CCM_PARAM_T_>(),
        72usize,
        concat!("Size of: ", stringify!(_MV_CC_CCM_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_CCM_PARAM_T_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_CC_CCM_PARAM_T_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_T_>())).bCCMEnable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_T_),
            "::",
            stringify!(bCCMEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_T_>())).nCCMat as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_T_),
            "::",
            stringify!(nCCMat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_T_>())).nRes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese CCM参数                   \\~english CCM param"]
pub type MV_CC_CCM_PARAM = _MV_CC_CCM_PARAM_T_;
#[doc = " \\~chinese CCM参数                   \\~english CCM param"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_CCM_PARAM_EX_T_ {
    #[doc = "< [IN]  \\~chinese 是否启用CCM            \\~english CCM enable"]
    pub bCCMEnable: bool_,
    #[doc = "< [IN]  \\~chinese CCM矩阵(-65536~65536)  \\~english Color correction matrix(-65536~65536)"]
    pub nCCMat: [::std::os::raw::c_int; 9usize],
    #[doc = "< [IN]  \\~chinese 量化系数（2的整数幂,最大65536）    \\~english Quantitative scale(Integer power of 2, <= 65536)"]
    pub nCCMScale: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_CCM_PARAM_EX_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_CCM_PARAM_EX_T_>(),
        76usize,
        concat!("Size of: ", stringify!(_MV_CC_CCM_PARAM_EX_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_CCM_PARAM_EX_T_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_CC_CCM_PARAM_EX_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_EX_T_>())).bCCMEnable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_EX_T_),
            "::",
            stringify!(bCCMEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_EX_T_>())).nCCMat as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_EX_T_),
            "::",
            stringify!(nCCMat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_EX_T_>())).nCCMScale as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_EX_T_),
            "::",
            stringify!(nCCMScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CCM_PARAM_EX_T_>())).nRes as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CCM_PARAM_EX_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese CCM参数                   \\~english CCM param"]
pub type MV_CC_CCM_PARAM_EX = _MV_CC_CCM_PARAM_EX_T_;
#[doc = " \\~chinese 水印信息                  \\~english  Frame-specific information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_FRAME_SPEC_INFO_ {
    #[doc = "< [OUT] \\~chinese 秒数                   \\~english The Seconds"]
    pub nSecondCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 周期数                 \\~english The Count of Cycle"]
    pub nCycleCount: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 周期偏移量             \\~english The Offset of Cycle"]
    pub nCycleOffset: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 增益                   \\~english Gain"]
    pub fGain: f32,
    #[doc = "< [OUT] \\~chinese 曝光时间               \\~english Exposure Time"]
    pub fExposureTime: f32,
    #[doc = "< [OUT] \\~chinese 平均亮度               \\~english Average brightness"]
    pub nAverageBrightness: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 红色                   \\~english Red"]
    pub nRed: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 绿色                   \\~english Green"]
    pub nGreen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 蓝色                   \\~english Blue"]
    pub nBlue: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 总帧数                 \\~english Frame Counter"]
    pub nFrameCounter: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 触发计数               \\~english Trigger Counting"]
    pub nTriggerIndex: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输入                   \\~english Input"]
    pub nInput: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出                   \\~english Output"]
    pub nOutput: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 水平偏移量             \\~english OffsetX"]
    pub nOffsetX: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 垂直偏移量             \\~english OffsetY"]
    pub nOffsetY: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 水印宽                 \\~english The Width of Chunk"]
    pub nFrameWidth: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 水印高                 \\~english The Height of Chunk"]
    pub nFrameHeight: ::std::os::raw::c_ushort,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout__MV_CC_FRAME_SPEC_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_FRAME_SPEC_INFO_>(),
        124usize,
        concat!("Size of: ", stringify!(_MV_CC_FRAME_SPEC_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_FRAME_SPEC_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_CC_FRAME_SPEC_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nSecondCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nSecondCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nCycleCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nCycleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nCycleOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nCycleOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).fGain as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(fGain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).fExposureTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(fExposureTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nAverageBrightness as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nAverageBrightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nRed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nRed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nGreen as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nGreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nBlue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nBlue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nFrameCounter as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nFrameCounter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nTriggerIndex as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nTriggerIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nInput as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nOutput as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nOutput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nOffsetX as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nOffsetX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nOffsetY as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nOffsetY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nFrameWidth as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nFrameWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nFrameHeight as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nFrameHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FRAME_SPEC_INFO_>())).nReserved as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FRAME_SPEC_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 水印信息                  \\~english  Frame-specific information"]
pub type MV_CC_FRAME_SPEC_INFO = _MV_CC_FRAME_SPEC_INFO_;
#[doc = " \\~chinese 无损解码参数              \\~english High Bandwidth decode structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_HB_DECODE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小           \\~english Input data size"]
    pub nSrcLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 图像宽                 \\~english Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 图像高                 \\~english Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据大小           \\~english Output data size"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出的像素格式         \\~english Output pixel format"]
    pub enDstPixelType: MvGvspPixelType,
    #[doc = "< [OUT] \\~chinese 水印信息               \\~english Frame Spec Info"]
    pub stFrameSpecInfo: MV_CC_FRAME_SPEC_INFO,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_HB_DECODE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_HB_DECODE_PARAM_T_>(),
        200usize,
        concat!("Size of: ", stringify!(_MV_CC_HB_DECODE_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_HB_DECODE_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_HB_DECODE_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).nSrcLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(nSrcLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).nWidth as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).nHeight as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).nDstBufSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).nDstBufLen as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).enDstPixelType as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(enDstPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).stFrameSpecInfo as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(stFrameSpecInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_HB_DECODE_PARAM_T_>())).nRes as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_HB_DECODE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 无损解码参数              \\~english High Bandwidth decode structure"]
pub type MV_CC_HB_DECODE_PARAM = _MV_CC_HB_DECODE_PARAM_T_;
#[doc = "< \\~chinese 未定义的录像格式             \\~english Undefined Recode Format Type"]
pub const _MV_RECORD_FORMAT_TYPE__MV_FormatType_Undefined: _MV_RECORD_FORMAT_TYPE_ = 0;
#[doc = "< \\~chinese AVI录像格式                  \\~english AVI Recode Format Type"]
pub const _MV_RECORD_FORMAT_TYPE__MV_FormatType_AVI: _MV_RECORD_FORMAT_TYPE_ = 1;
#[doc = " \\~chinese 录像格式定义              \\~english Record Format Type"]
pub type _MV_RECORD_FORMAT_TYPE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 录像格式定义              \\~english Record Format Type"]
pub use self::_MV_RECORD_FORMAT_TYPE_ as MV_RECORD_FORMAT_TYPE;
#[doc = " \\~chinese 录像参数                  \\~english Record Parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_RECORD_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 输入数据的像素格式     \\~english Pixel Type"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 图像宽(2的倍数)        \\~english Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 图像高(2的倍数)        \\~english Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [IN]  \\~chinese 帧率fps(大于1/16)      \\~english The Rate of Frame"]
    pub fFrameRate: f32,
    #[doc = "< [IN]  \\~chinese 码率kbps(128-16*1024)  \\~english The Rate of Bitrate"]
    pub nBitRate: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 录像格式               \\~english Recode Format Type"]
    pub enRecordFmtType: MV_RECORD_FORMAT_TYPE,
    #[doc = "< [IN]  \\~chinese 录像文件存放路径(如果路径中存在中文，需转成utf-8)  \\~english File Path"]
    pub strFilePath: *mut ::std::os::raw::c_char,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_RECORD_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_RECORD_PARAM_T_>(),
        64usize,
        concat!("Size of: ", stringify!(_MV_CC_RECORD_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_RECORD_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_RECORD_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).enPixelType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).nWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).nHeight as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).fFrameRate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(fFrameRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).nBitRate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(nBitRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).enRecordFmtType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(enRecordFmtType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).strFilePath as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(strFilePath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECORD_PARAM_T_>())).nRes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECORD_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 录像参数                  \\~english Record Parameters"]
pub type MV_CC_RECORD_PARAM = _MV_CC_RECORD_PARAM_T_;
#[doc = " \\~chinese 传入的图像数据            \\~english Input Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_INPUT_FRAME_INFO_T_ {
    #[doc = "< [IN]  \\~chinese 图像数据指针           \\~english Record Data"]
    pub pData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 图像大小               \\~english The Length of Record Data"]
    pub nDataLen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_INPUT_FRAME_INFO_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_INPUT_FRAME_INFO_T_>(),
        48usize,
        concat!("Size of: ", stringify!(_MV_CC_INPUT_FRAME_INFO_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_INPUT_FRAME_INFO_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_INPUT_FRAME_INFO_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_INPUT_FRAME_INFO_T_>())).pData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_INPUT_FRAME_INFO_T_),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_INPUT_FRAME_INFO_T_>())).nDataLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_INPUT_FRAME_INFO_T_),
            "::",
            stringify!(nDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_INPUT_FRAME_INFO_T_>())).nRes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_INPUT_FRAME_INFO_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 传入的图像数据            \\~english Input Data"]
pub type MV_CC_INPUT_FRAME_INFO = _MV_CC_INPUT_FRAME_INFO_T_;
#[doc = "< \\~chinese 单帧模式                     \\~english Single Mode"]
pub const _MV_CAM_ACQUISITION_MODE__MV_ACQ_MODE_SINGLE: _MV_CAM_ACQUISITION_MODE_ = 0;
#[doc = "< \\~chinese 多帧模式                     \\~english Multi Mode"]
pub const _MV_CAM_ACQUISITION_MODE__MV_ACQ_MODE_MUTLI: _MV_CAM_ACQUISITION_MODE_ = 1;
#[doc = "< \\~chinese 持续采集模式                 \\~english Continuous Mode"]
pub const _MV_CAM_ACQUISITION_MODE__MV_ACQ_MODE_CONTINUOUS: _MV_CAM_ACQUISITION_MODE_ = 2;
#[doc = " \\~chinese 采集模式                  \\~english Acquisition mode"]
pub type _MV_CAM_ACQUISITION_MODE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 采集模式                  \\~english Acquisition mode"]
pub use self::_MV_CAM_ACQUISITION_MODE_ as MV_CAM_ACQUISITION_MODE;
#[doc = "< \\~chinese 关闭                         \\~english Single Mode"]
pub const _MV_CAM_GAIN_MODE__MV_GAIN_MODE_OFF: _MV_CAM_GAIN_MODE_ = 0;
#[doc = "< \\~chinese 一次                         \\~english Multi Mode"]
pub const _MV_CAM_GAIN_MODE__MV_GAIN_MODE_ONCE: _MV_CAM_GAIN_MODE_ = 1;
#[doc = "< \\~chinese 连续                         \\~english Continuous Mode"]
pub const _MV_CAM_GAIN_MODE__MV_GAIN_MODE_CONTINUOUS: _MV_CAM_GAIN_MODE_ = 2;
#[doc = " \\~chinese 增益模式                  \\~english Gain Mode"]
pub type _MV_CAM_GAIN_MODE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 增益模式                  \\~english Gain Mode"]
pub use self::_MV_CAM_GAIN_MODE_ as MV_CAM_GAIN_MODE;
#[doc = "< \\~chinese 时间                         \\~english Timed"]
pub const _MV_CAM_EXPOSURE_MODE__MV_EXPOSURE_MODE_TIMED: _MV_CAM_EXPOSURE_MODE_ = 0;
#[doc = "< \\~chinese 触发脉冲宽度                 \\~english TriggerWidth"]
pub const _MV_CAM_EXPOSURE_MODE__MV_EXPOSURE_MODE_TRIGGER_WIDTH: _MV_CAM_EXPOSURE_MODE_ = 1;
#[doc = " \\~chinese 曝光模式                  \\~english Exposure Mode"]
pub type _MV_CAM_EXPOSURE_MODE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 曝光模式                  \\~english Exposure Mode"]
pub use self::_MV_CAM_EXPOSURE_MODE_ as MV_CAM_EXPOSURE_MODE;
#[doc = "< \\~chinese 关闭                         \\~english Off"]
pub const _MV_CAM_EXPOSURE_AUTO_MODE__MV_EXPOSURE_AUTO_MODE_OFF: _MV_CAM_EXPOSURE_AUTO_MODE_ = 0;
#[doc = "< \\~chinese 一次                         \\~english Once"]
pub const _MV_CAM_EXPOSURE_AUTO_MODE__MV_EXPOSURE_AUTO_MODE_ONCE: _MV_CAM_EXPOSURE_AUTO_MODE_ = 1;
#[doc = "< \\~chinese 连续                         \\~english Continuous"]
pub const _MV_CAM_EXPOSURE_AUTO_MODE__MV_EXPOSURE_AUTO_MODE_CONTINUOUS:
    _MV_CAM_EXPOSURE_AUTO_MODE_ = 2;
#[doc = " \\~chinese 自动曝光模式              \\~english Auto Exposure Mode"]
pub type _MV_CAM_EXPOSURE_AUTO_MODE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 自动曝光模式              \\~english Auto Exposure Mode"]
pub use self::_MV_CAM_EXPOSURE_AUTO_MODE_ as MV_CAM_EXPOSURE_AUTO_MODE;
#[doc = "< \\~chinese 关闭                         \\~english Off"]
pub const _MV_CAM_TRIGGER_MODE__MV_TRIGGER_MODE_OFF: _MV_CAM_TRIGGER_MODE_ = 0;
#[doc = "< \\~chinese 打开                         \\~english ON"]
pub const _MV_CAM_TRIGGER_MODE__MV_TRIGGER_MODE_ON: _MV_CAM_TRIGGER_MODE_ = 1;
#[doc = " \\~chinese 触发模式                  \\~english Trigger Mode"]
pub type _MV_CAM_TRIGGER_MODE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 触发模式                  \\~english Trigger Mode"]
pub use self::_MV_CAM_TRIGGER_MODE_ as MV_CAM_TRIGGER_MODE;
#[doc = "< \\~chinese 用户                         \\~english Gamma Selector User"]
pub const _MV_CAM_GAMMA_SELECTOR__MV_GAMMA_SELECTOR_USER: _MV_CAM_GAMMA_SELECTOR_ = 1;
#[doc = "< \\~chinese sRGB                         \\~english Gamma Selector sRGB"]
pub const _MV_CAM_GAMMA_SELECTOR__MV_GAMMA_SELECTOR_SRGB: _MV_CAM_GAMMA_SELECTOR_ = 2;
#[doc = " \\~chinese Gamma选择器               \\~english Gamma Selector"]
pub type _MV_CAM_GAMMA_SELECTOR_ = ::std::os::raw::c_int;
#[doc = " \\~chinese Gamma选择器               \\~english Gamma Selector"]
pub use self::_MV_CAM_GAMMA_SELECTOR_ as MV_CAM_GAMMA_SELECTOR;
#[doc = "< \\~chinese 关闭                         \\~english Off"]
pub const _MV_CAM_BALANCEWHITE_AUTO__MV_BALANCEWHITE_AUTO_OFF: _MV_CAM_BALANCEWHITE_AUTO_ = 0;
#[doc = "< \\~chinese 一次                         \\~english Once"]
pub const _MV_CAM_BALANCEWHITE_AUTO__MV_BALANCEWHITE_AUTO_ONCE: _MV_CAM_BALANCEWHITE_AUTO_ = 2;
#[doc = "< \\~chinese 连续                         \\~english Continuous"]
pub const _MV_CAM_BALANCEWHITE_AUTO__MV_BALANCEWHITE_AUTO_CONTINUOUS: _MV_CAM_BALANCEWHITE_AUTO_ =
    1;
#[doc = " \\~chinese 白平衡                    \\~english White Balance"]
pub type _MV_CAM_BALANCEWHITE_AUTO_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 白平衡                    \\~english White Balance"]
pub use self::_MV_CAM_BALANCEWHITE_AUTO_ as MV_CAM_BALANCEWHITE_AUTO;
#[doc = "< \\~chinese Line0                        \\~english Line0"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_LINE0: _MV_CAM_TRIGGER_SOURCE_ = 0;
#[doc = "< \\~chinese Line1                        \\~english Line1"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_LINE1: _MV_CAM_TRIGGER_SOURCE_ = 1;
#[doc = "< \\~chinese Line2                        \\~english Line2"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_LINE2: _MV_CAM_TRIGGER_SOURCE_ = 2;
#[doc = "< \\~chinese Line3                        \\~english Line3"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_LINE3: _MV_CAM_TRIGGER_SOURCE_ = 3;
#[doc = "< \\~chinese Conuter0                     \\~english Conuter0"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_COUNTER0: _MV_CAM_TRIGGER_SOURCE_ = 4;
#[doc = "< \\~chinese 软触发                       \\~english Software"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_SOFTWARE: _MV_CAM_TRIGGER_SOURCE_ = 7;
#[doc = "< \\~chinese 变频器                       \\~english Frequency Converter"]
pub const _MV_CAM_TRIGGER_SOURCE__MV_TRIGGER_SOURCE_FrequencyConverter: _MV_CAM_TRIGGER_SOURCE_ = 8;
#[doc = " \\~chinese 触发源                    \\~english Trigger Source"]
pub type _MV_CAM_TRIGGER_SOURCE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese 触发源                    \\~english Trigger Source"]
pub use self::_MV_CAM_TRIGGER_SOURCE_ as MV_CAM_TRIGGER_SOURCE;
#[doc = " \\~chinese Event事件回调信息\\        \\~english Event callback infomation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_EVENT_OUT_INFO_ {
    #[doc = "< [OUT] \\~chinese Event名称              \\~english Event name"]
    pub EventName: [::std::os::raw::c_char; 128usize],
    #[doc = "< [OUT] \\~chinese Event号                \\~english Event ID"]
    pub nEventID: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 流通道序号             \\~english Circulation number"]
    pub nStreamChannel: ::std::os::raw::c_ushort,
    #[doc = "< [OUT] \\~chinese 帧号高位               \\~english BlockId high"]
    pub nBlockIdHigh: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 帧号低位               \\~english BlockId low"]
    pub nBlockIdLow: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 时间戳高位             \\~english Timestramp high"]
    pub nTimestampHigh: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 时间戳低位             \\~english Timestramp low"]
    pub nTimestampLow: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese Event数据              \\~english Event data"]
    pub pEventData: *mut ::std::os::raw::c_void,
    #[doc = "< [OUT] \\~chinese Event数据长度          \\~english Event data len"]
    pub nEventDataSize: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout__MV_EVENT_OUT_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_EVENT_OUT_INFO_>(),
        232usize,
        concat!("Size of: ", stringify!(_MV_EVENT_OUT_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_EVENT_OUT_INFO_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_EVENT_OUT_INFO_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).EventName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(EventName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nEventID as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nEventID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nStreamChannel as *const _ as usize
        },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nStreamChannel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nBlockIdHigh as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nBlockIdHigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nBlockIdLow as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nBlockIdLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nTimestampHigh as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nTimestampHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nTimestampLow as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nTimestampLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).pEventData as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(pEventData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nEventDataSize as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nEventDataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_EVENT_OUT_INFO_>())).nReserved as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_EVENT_OUT_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese Event事件回调信息\\        \\~english Event callback infomation"]
pub type MV_EVENT_OUT_INFO = _MV_EVENT_OUT_INFO_;
#[doc = " \\~chinese 文件存取                  \\~english File Access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_FILE_ACCESS_T {
    #[doc = "< [IN]  \\~chinese 用户文件名             \\~english User file name"]
    pub pUserFileName: *const ::std::os::raw::c_char,
    #[doc = "< [IN]  \\~chinese 设备文件名             \\~english Device file name"]
    pub pDevFileName: *const ::std::os::raw::c_char,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 32usize],
}
#[test]
fn bindgen_test_layout__MV_CC_FILE_ACCESS_T() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_FILE_ACCESS_T>(),
        144usize,
        concat!("Size of: ", stringify!(_MV_CC_FILE_ACCESS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_FILE_ACCESS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_FILE_ACCESS_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FILE_ACCESS_T>())).pUserFileName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FILE_ACCESS_T),
            "::",
            stringify!(pUserFileName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FILE_ACCESS_T>())).pDevFileName as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FILE_ACCESS_T),
            "::",
            stringify!(pDevFileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_FILE_ACCESS_T>())).nReserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FILE_ACCESS_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 文件存取                  \\~english File Access"]
pub type MV_CC_FILE_ACCESS = _MV_CC_FILE_ACCESS_T;
#[doc = " \\~chinese 文件存取进度              \\~english File Access Progress"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_FILE_ACCESS_PROGRESS_T {
    #[doc = "< [OUT] \\~chinese 已完成的长度           \\~english Completed Length"]
    pub nCompleted: i64,
    #[doc = "< [OUT] \\~chinese 总长度                 \\~english Total Length"]
    pub nTotal: i64,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_FILE_ACCESS_PROGRESS_T() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_FILE_ACCESS_PROGRESS_T>(),
        48usize,
        concat!("Size of: ", stringify!(_MV_CC_FILE_ACCESS_PROGRESS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_FILE_ACCESS_PROGRESS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_FILE_ACCESS_PROGRESS_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FILE_ACCESS_PROGRESS_T>())).nCompleted as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FILE_ACCESS_PROGRESS_T),
            "::",
            stringify!(nCompleted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FILE_ACCESS_PROGRESS_T>())).nTotal as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FILE_ACCESS_PROGRESS_T),
            "::",
            stringify!(nTotal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_FILE_ACCESS_PROGRESS_T>())).nReserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_FILE_ACCESS_PROGRESS_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 文件存取进度              \\~english File Access Progress"]
pub type MV_CC_FILE_ACCESS_PROGRESS = _MV_CC_FILE_ACCESS_PROGRESS_T;
#[doc = "< \\~chinese 表示单播(默认)                           \\~english Unicast mode"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_UNICAST: _MV_GIGE_TRANSMISSION_TYPE_ = 0;
#[doc = "< \\~chinese 表示组播                                 \\~english Multicast mode"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_MULTICAST: _MV_GIGE_TRANSMISSION_TYPE_ = 1;
#[doc = "< \\~chinese 表示局域网内广播，暂不支持               \\~english Limited broadcast mode,not support"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_LIMITEDBROADCAST:
    _MV_GIGE_TRANSMISSION_TYPE_ = 2;
#[doc = "< \\~chinese 表示子网内广播，暂不支持                 \\~english Subnet broadcast mode,not support"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_SUBNETBROADCAST:
    _MV_GIGE_TRANSMISSION_TYPE_ = 3;
#[doc = "< \\~chinese 表示从设备获取，暂不支持                 \\~english Transtype from camera,not support"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_CAMERADEFINED: _MV_GIGE_TRANSMISSION_TYPE_ =
    4;
#[doc = "< \\~chinese 表示用户自定义应用端接收图像数据Port号   \\~english User Defined Receive Data Port"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT:
    _MV_GIGE_TRANSMISSION_TYPE_ = 5;
#[doc = "< \\~chinese 表示设置了单播，但本实例不接收图像数据   \\~english Unicast without receive data"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV:
    _MV_GIGE_TRANSMISSION_TYPE_ = 65536;
#[doc = "< \\~chinese 表示组播模式，但本实例不接收图像数据     \\~english Multicast without receive data"]
pub const _MV_GIGE_TRANSMISSION_TYPE__MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV:
    _MV_GIGE_TRANSMISSION_TYPE_ = 65537;
#[doc = " \\~chinese Gige的传输类型            \\~english The transmission type of Gige"]
pub type _MV_GIGE_TRANSMISSION_TYPE_ = ::std::os::raw::c_int;
#[doc = " \\~chinese Gige的传输类型            \\~english The transmission type of Gige"]
pub use self::_MV_GIGE_TRANSMISSION_TYPE_ as MV_GIGE_TRANSMISSION_TYPE;
#[doc = " \\~chinese 网络传输模式              \\~english Transmission type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_TRANSMISSION_TYPE_T {
    #[doc = "< [IN]  \\~chinese 传输模式                   \\~english Transmission type"]
    pub enTransmissionType: MV_GIGE_TRANSMISSION_TYPE,
    #[doc = "< [IN]  \\~chinese 目标IP，组播模式下有意义   \\~english Destination IP"]
    pub nDestIp: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 目标Port，组播模式下有意义 \\~english Destination port"]
    pub nDestPort: ::std::os::raw::c_ushort,
    #[doc = "<       \\~chinese 预留                       \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 32usize],
}
#[test]
fn bindgen_test_layout__MV_TRANSMISSION_TYPE_T() {
    assert_eq!(
        ::std::mem::size_of::<_MV_TRANSMISSION_TYPE_T>(),
        140usize,
        concat!("Size of: ", stringify!(_MV_TRANSMISSION_TYPE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_TRANSMISSION_TYPE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_TRANSMISSION_TYPE_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_TRANSMISSION_TYPE_T>())).enTransmissionType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_TRANSMISSION_TYPE_T),
            "::",
            stringify!(enTransmissionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_TRANSMISSION_TYPE_T>())).nDestIp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_TRANSMISSION_TYPE_T),
            "::",
            stringify!(nDestIp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_TRANSMISSION_TYPE_T>())).nDestPort as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_TRANSMISSION_TYPE_T),
            "::",
            stringify!(nDestPort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_TRANSMISSION_TYPE_T>())).nReserved as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_TRANSMISSION_TYPE_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 网络传输模式              \\~english Transmission type"]
pub type MV_TRANSMISSION_TYPE = _MV_TRANSMISSION_TYPE_T;
#[doc = " \\~chinese 动作命令信息              \\~english Action Command"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_ACTION_CMD_INFO_T {
    #[doc = "< [IN]  \\~chinese 设备密钥                                   \\~english Device Key;"]
    pub nDeviceKey: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 组键                                       \\~english Group Key"]
    pub nGroupKey: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 组掩码                                     \\~english Group Mask"]
    pub nGroupMask: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 只有设置成1时Action Time才有效，非1时无效  \\~english Action Time Enable"]
    pub bActionTimeEnable: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 预定的时间，和主频有关                     \\~english Action Time"]
    pub nActionTime: i64,
    #[doc = "< [IN]  \\~chinese 广播包地址                                 \\~english Broadcast Address"]
    pub pBroadcastAddress: *const ::std::os::raw::c_char,
    #[doc = "< [IN]  \\~chinese 等待ACK的超时时间，如果为0表示不需要ACK    \\~english TimeOut"]
    pub nTimeOut: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 只有设置成1时指定的网卡IP才有效，非1时无效 \\~english Special IP Enable"]
    pub bSpecialNetEnable: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 指定的网卡IP                               \\~english Special Net IP address"]
    pub nSpecialNetIP: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                                       \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 14usize],
}
#[test]
fn bindgen_test_layout__MV_ACTION_CMD_INFO_T() {
    assert_eq!(
        ::std::mem::size_of::<_MV_ACTION_CMD_INFO_T>(),
        104usize,
        concat!("Size of: ", stringify!(_MV_ACTION_CMD_INFO_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_ACTION_CMD_INFO_T>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_ACTION_CMD_INFO_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nDeviceKey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nDeviceKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nGroupKey as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nGroupKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nGroupMask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nGroupMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).bActionTimeEnable as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(bActionTimeEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nActionTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nActionTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).pBroadcastAddress as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(pBroadcastAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nTimeOut as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nTimeOut)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).bSpecialNetEnable as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(bSpecialNetEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nSpecialNetIP as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nSpecialNetIP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ACTION_CMD_INFO_T>())).nReserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_INFO_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 动作命令信息              \\~english Action Command"]
pub type MV_ACTION_CMD_INFO = _MV_ACTION_CMD_INFO_T;
#[doc = " \\~chinese 动作命令返回信息          \\~english Action Command Result"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_ACTION_CMD_RESULT_T {
    #[doc = "< [OUT] \\~chinese 设备IP                 \\~english IP address of the device"]
    pub strDeviceAddress: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< [OUT] \\~chinese 状态码                 \\~english status code returned by the device"]
    pub nStatus: ::std::os::raw::c_int,
    #[doc = "<      \\~chinese 预留                    \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_ACTION_CMD_RESULT_T() {
    assert_eq!(
        ::std::mem::size_of::<_MV_ACTION_CMD_RESULT_T>(),
        36usize,
        concat!("Size of: ", stringify!(_MV_ACTION_CMD_RESULT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_ACTION_CMD_RESULT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_ACTION_CMD_RESULT_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_RESULT_T>())).strDeviceAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_RESULT_T),
            "::",
            stringify!(strDeviceAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_ACTION_CMD_RESULT_T>())).nStatus as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_RESULT_T),
            "::",
            stringify!(nStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_RESULT_T>())).nReserved as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_RESULT_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 动作命令返回信息          \\~english Action Command Result"]
pub type MV_ACTION_CMD_RESULT = _MV_ACTION_CMD_RESULT_T;
#[doc = " \\~chinese 动作命令返回信息列表      \\~english Action Command Result List"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_ACTION_CMD_RESULT_LIST_T {
    #[doc = "< [OUT] \\~chinese 返回值个数             \\~english Number of returned values"]
    pub nNumResults: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 动作命令结果           \\~english Reslut of action command"]
    pub pResults: *mut MV_ACTION_CMD_RESULT,
}
#[test]
fn bindgen_test_layout__MV_ACTION_CMD_RESULT_LIST_T() {
    assert_eq!(
        ::std::mem::size_of::<_MV_ACTION_CMD_RESULT_LIST_T>(),
        16usize,
        concat!("Size of: ", stringify!(_MV_ACTION_CMD_RESULT_LIST_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_ACTION_CMD_RESULT_LIST_T>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_ACTION_CMD_RESULT_LIST_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_RESULT_LIST_T>())).nNumResults as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_RESULT_LIST_T),
            "::",
            stringify!(nNumResults)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_ACTION_CMD_RESULT_LIST_T>())).pResults as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_ACTION_CMD_RESULT_LIST_T),
            "::",
            stringify!(pResults)
        )
    );
}
#[doc = " \\~chinese 动作命令返回信息列表      \\~english Action Command Result List"]
pub type MV_ACTION_CMD_RESULT_LIST = _MV_ACTION_CMD_RESULT_LIST_T;
#[doc = "< \\~chinese Value                        \\~english IValue interface"]
pub const MV_XML_InterfaceType_IFT_IValue: MV_XML_InterfaceType = 0;
#[doc = "< \\~chinese Base                         \\~english IBase interface"]
pub const MV_XML_InterfaceType_IFT_IBase: MV_XML_InterfaceType = 1;
#[doc = "< \\~chinese Integer                      \\~english IInteger interface"]
pub const MV_XML_InterfaceType_IFT_IInteger: MV_XML_InterfaceType = 2;
#[doc = "< \\~chinese Boolean                      \\~english IBoolean interface"]
pub const MV_XML_InterfaceType_IFT_IBoolean: MV_XML_InterfaceType = 3;
#[doc = "< \\~chinese Command                      \\~english ICommand interface"]
pub const MV_XML_InterfaceType_IFT_ICommand: MV_XML_InterfaceType = 4;
#[doc = "< \\~chinese Float                        \\~english IFloat interface"]
pub const MV_XML_InterfaceType_IFT_IFloat: MV_XML_InterfaceType = 5;
#[doc = "< \\~chinese String                       \\~english IString interface"]
pub const MV_XML_InterfaceType_IFT_IString: MV_XML_InterfaceType = 6;
#[doc = "< \\~chinese Register                     \\~english IRegister interface"]
pub const MV_XML_InterfaceType_IFT_IRegister: MV_XML_InterfaceType = 7;
#[doc = "< \\~chinese Category                     \\~english ICategory interface"]
pub const MV_XML_InterfaceType_IFT_ICategory: MV_XML_InterfaceType = 8;
#[doc = "< \\~chinese Enumeration                  \\~english IEnumeration interface"]
pub const MV_XML_InterfaceType_IFT_IEnumeration: MV_XML_InterfaceType = 9;
#[doc = "< \\~chinese EnumEntry                    \\~english IEnumEntry interface"]
pub const MV_XML_InterfaceType_IFT_IEnumEntry: MV_XML_InterfaceType = 10;
#[doc = "< \\~chinese Port                         \\~english IPort interface"]
pub const MV_XML_InterfaceType_IFT_IPort: MV_XML_InterfaceType = 11;
#[doc = " \\~chinese 每个节点对应的接口类型    \\~english Interface type corresponds to each node"]
pub type MV_XML_InterfaceType = ::std::os::raw::c_int;
#[doc = "< \\~chinese 不可实现                     \\~english Not implemented"]
pub const MV_XML_AccessMode_AM_NI: MV_XML_AccessMode = 0;
#[doc = "< \\~chinese 不可用                       \\~english Not available"]
pub const MV_XML_AccessMode_AM_NA: MV_XML_AccessMode = 1;
#[doc = "< \\~chinese 只写                         \\~english Write Only"]
pub const MV_XML_AccessMode_AM_WO: MV_XML_AccessMode = 2;
#[doc = "< \\~chinese 只读                         \\~english Read Only"]
pub const MV_XML_AccessMode_AM_RO: MV_XML_AccessMode = 3;
#[doc = "< \\~chinese 读写                         \\~english Read and Write"]
pub const MV_XML_AccessMode_AM_RW: MV_XML_AccessMode = 4;
#[doc = "< \\~chinese 未定义                       \\~english Object is not yet initialized"]
pub const MV_XML_AccessMode_AM_Undefined: MV_XML_AccessMode = 5;
#[doc = "< \\~chinese 内部用于AccessMode循环检测   \\~english used internally for AccessMode cycle detection"]
pub const MV_XML_AccessMode_AM_CycleDetect: MV_XML_AccessMode = 6;
#[doc = " \\~chinese 节点的访问模式            \\~english Node Access Mode"]
pub type MV_XML_AccessMode = ::std::os::raw::c_int;
#[doc = " \\~chinese 枚举类型值                \\~english Enumeration Value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MVCC_ENUMVALUE_T {
    #[doc = "< [OUT] \\~chinese 当前值                 \\~english Current Value"]
    pub nCurValue: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 数据的有效数据个数     \\~english Number of valid data"]
    pub nSupportedNum: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 支持的枚举值           \\~english Support Value"]
    pub nSupportValue: [::std::os::raw::c_uint; 64usize],
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MVCC_ENUMVALUE_T() {
    assert_eq!(
        ::std::mem::size_of::<_MVCC_ENUMVALUE_T>(),
        280usize,
        concat!("Size of: ", stringify!(_MVCC_ENUMVALUE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MVCC_ENUMVALUE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(_MVCC_ENUMVALUE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_ENUMVALUE_T>())).nCurValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_ENUMVALUE_T),
            "::",
            stringify!(nCurValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_ENUMVALUE_T>())).nSupportedNum as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_ENUMVALUE_T),
            "::",
            stringify!(nSupportedNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_ENUMVALUE_T>())).nSupportValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_ENUMVALUE_T),
            "::",
            stringify!(nSupportValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_ENUMVALUE_T>())).nReserved as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_ENUMVALUE_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 枚举类型值                \\~english Enumeration Value"]
pub type MVCC_ENUMVALUE = _MVCC_ENUMVALUE_T;
#[doc = " \\~chinese Int类型值                 \\~english Int Value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MVCC_INTVALUE_T {
    #[doc = "< [OUT] \\~chinese 当前值                 \\~english Current Value"]
    pub nCurValue: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 最大值                 \\~english Max"]
    pub nMax: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 最小值                 \\~english Min"]
    pub nMin: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese                        \\~english Inc"]
    pub nInc: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MVCC_INTVALUE_T() {
    assert_eq!(
        ::std::mem::size_of::<_MVCC_INTVALUE_T>(),
        32usize,
        concat!("Size of: ", stringify!(_MVCC_INTVALUE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MVCC_INTVALUE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(_MVCC_INTVALUE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_T>())).nCurValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_T),
            "::",
            stringify!(nCurValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_T>())).nMax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_T),
            "::",
            stringify!(nMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_T>())).nMin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_T),
            "::",
            stringify!(nMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_T>())).nInc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_T),
            "::",
            stringify!(nInc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_T>())).nReserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese Int类型值                 \\~english Int Value"]
pub type MVCC_INTVALUE = _MVCC_INTVALUE_T;
#[doc = " \\~chinese Int类型值Ex               \\~english Int Value Ex"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MVCC_INTVALUE_EX_T {
    #[doc = "< [OUT] \\~chinese 当前值                 \\~english Current Value"]
    pub nCurValue: i64,
    #[doc = "< [OUT] \\~chinese 最大值                 \\~english Max"]
    pub nMax: i64,
    #[doc = "< [OUT] \\~chinese 最小值                 \\~english Min"]
    pub nMin: i64,
    #[doc = "< [OUT] \\~chinese Inc                    \\~english Inc"]
    pub nInc: i64,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout__MVCC_INTVALUE_EX_T() {
    assert_eq!(
        ::std::mem::size_of::<_MVCC_INTVALUE_EX_T>(),
        96usize,
        concat!("Size of: ", stringify!(_MVCC_INTVALUE_EX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MVCC_INTVALUE_EX_T>(),
        8usize,
        concat!("Alignment of ", stringify!(_MVCC_INTVALUE_EX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_EX_T>())).nCurValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_EX_T),
            "::",
            stringify!(nCurValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_EX_T>())).nMax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_EX_T),
            "::",
            stringify!(nMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_EX_T>())).nMin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_EX_T),
            "::",
            stringify!(nMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_EX_T>())).nInc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_EX_T),
            "::",
            stringify!(nInc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_INTVALUE_EX_T>())).nReserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_INTVALUE_EX_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese Int类型值Ex               \\~english Int Value Ex"]
pub type MVCC_INTVALUE_EX = _MVCC_INTVALUE_EX_T;
#[doc = " \\~chinese Float类型值               \\~english Float Value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MVCC_FLOATVALUE_T {
    #[doc = "< [OUT] \\~chinese 当前值                 \\~english Current Value"]
    pub fCurValue: f32,
    #[doc = "< [OUT] \\~chinese 最大值                 \\~english Max"]
    pub fMax: f32,
    #[doc = "< [OUT] \\~chinese 最小值                 \\~english Min"]
    pub fMin: f32,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MVCC_FLOATVALUE_T() {
    assert_eq!(
        ::std::mem::size_of::<_MVCC_FLOATVALUE_T>(),
        28usize,
        concat!("Size of: ", stringify!(_MVCC_FLOATVALUE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MVCC_FLOATVALUE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(_MVCC_FLOATVALUE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_FLOATVALUE_T>())).fCurValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_FLOATVALUE_T),
            "::",
            stringify!(fCurValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_FLOATVALUE_T>())).fMax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_FLOATVALUE_T),
            "::",
            stringify!(fMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_FLOATVALUE_T>())).fMin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_FLOATVALUE_T),
            "::",
            stringify!(fMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_FLOATVALUE_T>())).nReserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_FLOATVALUE_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese Float类型值               \\~english Float Value"]
pub type MVCC_FLOATVALUE = _MVCC_FLOATVALUE_T;
#[doc = " \\~chinese String类型值              \\~english String Value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MVCC_STRINGVALUE_T {
    #[doc = "< [OUT] \\~chinese 当前值                 \\~english Current Value"]
    pub chCurValue: [::std::os::raw::c_char; 256usize],
    #[doc = "< [OUT] \\~chinese 最大长度               \\~english MaxLength"]
    pub nMaxLength: i64,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nReserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout__MVCC_STRINGVALUE_T() {
    assert_eq!(
        ::std::mem::size_of::<_MVCC_STRINGVALUE_T>(),
        272usize,
        concat!("Size of: ", stringify!(_MVCC_STRINGVALUE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<_MVCC_STRINGVALUE_T>(),
        8usize,
        concat!("Alignment of ", stringify!(_MVCC_STRINGVALUE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_STRINGVALUE_T>())).chCurValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_STRINGVALUE_T),
            "::",
            stringify!(chCurValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_STRINGVALUE_T>())).nMaxLength as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_STRINGVALUE_T),
            "::",
            stringify!(nMaxLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MVCC_STRINGVALUE_T>())).nReserved as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_MVCC_STRINGVALUE_T),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese String类型值              \\~english String Value"]
pub type MVCC_STRINGVALUE = _MVCC_STRINGVALUE_T;
#[doc = " \\~chinese 输出帧的信息             \\~english Output Frame Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_FRAME_OUT_INFO_ {
    #[doc = "< [OUT]  \\~chinese 图像宽            \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [OUT]  \\~chinese 图像高            \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [OUT]  \\~chinese 像素格式          \\~english Pixel Type"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [OUT]  \\~chinese 帧号              \\~english Frame Number"]
    pub nFrameNum: ::std::os::raw::c_uint,
    #[doc = "< [OUT]  \\~chinese 时间戳高32位      \\~english Timestamp high 32 bits"]
    pub nDevTimeStampHigh: ::std::os::raw::c_uint,
    #[doc = "< [OUT]  \\~chinese 时间戳低32位      \\~english Timestamp low 32 bits"]
    pub nDevTimeStampLow: ::std::os::raw::c_uint,
    #[doc = "< [OUT]  \\~chinese 保留，8字节对齐   \\~english Reserved, 8-byte aligned"]
    pub nReserved0: ::std::os::raw::c_uint,
    #[doc = "< [OUT]  \\~chinese 主机生成的时间戳  \\~english Host-generated timestamp"]
    pub nHostTimeStamp: i64,
    pub nFrameLen: ::std::os::raw::c_uint,
    pub nLostPacket: ::std::os::raw::c_uint,
    pub nReserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout__MV_FRAME_OUT_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_FRAME_OUT_INFO_>(),
        48usize,
        concat!("Size of: ", stringify!(_MV_FRAME_OUT_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_FRAME_OUT_INFO_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_FRAME_OUT_INFO_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nHeight as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).enPixelType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nFrameNum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nFrameNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nDevTimeStampHigh as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nDevTimeStampHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nDevTimeStampLow as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nDevTimeStampLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nReserved0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nReserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nHostTimeStamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nHostTimeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nFrameLen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nFrameLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nLostPacket as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nLostPacket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_FRAME_OUT_INFO_>())).nReserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_FRAME_OUT_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 输出帧的信息             \\~english Output Frame Information"]
pub type MV_FRAME_OUT_INFO = _MV_FRAME_OUT_INFO_;
#[doc = " \\~chinese 保存图片参数            \\~english Save image type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_SAVE_IMAGE_PARAM_T_ {
    #[doc = "< [IN]   \\~chinese 输入数据缓存      \\~english Input Data Buffer"]
    pub pData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]   \\~chinese 输入数据大小      \\~english Input Data Size"]
    pub nDataLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]   \\~chinese 输入像素格式      \\~english Input Data Pixel Format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]   \\~chinese 图像宽            \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_ushort,
    #[doc = "< [IN]   \\~chinese 图像高            \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_ushort,
    #[doc = "< [OUT]  \\~chinese 输出图片缓存      \\~english Output Image Buffer"]
    pub pImageBuffer: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT]  \\~chinese 输出图片大小      \\~english Output Image Size"]
    pub nImageLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]   \\~chinese 提供的输出缓冲区大小  \\~english Output buffer size provided"]
    pub nBufferSize: ::std::os::raw::c_uint,
    #[doc = "< [IN]   \\~chinese 输出图片格式      \\~english Output Image Format"]
    pub enImageType: MV_SAVE_IAMGE_TYPE,
}
#[test]
fn bindgen_test_layout__MV_SAVE_IMAGE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_SAVE_IMAGE_PARAM_T_>(),
        48usize,
        concat!("Size of: ", stringify!(_MV_SAVE_IMAGE_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_SAVE_IMAGE_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_SAVE_IMAGE_PARAM_T_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).pData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).nDataLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(nDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).enPixelType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).nWidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).nHeight as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).pImageBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(pImageBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).nImageLen as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(nImageLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).nBufferSize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(nBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_SAVE_IMAGE_PARAM_T_>())).enImageType as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_SAVE_IMAGE_PARAM_T_),
            "::",
            stringify!(enImageType)
        )
    );
}
#[doc = " \\~chinese 保存图片参数            \\~english Save image type"]
pub type MV_SAVE_IMAGE_PARAM = _MV_SAVE_IMAGE_PARAM_T_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_IMAGE_BASIC_INFO_ {
    pub nWidthValue: ::std::os::raw::c_ushort,
    pub nWidthMin: ::std::os::raw::c_ushort,
    pub nWidthMax: ::std::os::raw::c_uint,
    pub nWidthInc: ::std::os::raw::c_uint,
    pub nHeightValue: ::std::os::raw::c_uint,
    pub nHeightMin: ::std::os::raw::c_uint,
    pub nHeightMax: ::std::os::raw::c_uint,
    pub nHeightInc: ::std::os::raw::c_uint,
    pub fFrameRateValue: f32,
    pub fFrameRateMin: f32,
    pub fFrameRateMax: f32,
    #[doc = "< [OUT]  \\~chinese 当前的像素格式    \\~english Current pixel format"]
    pub enPixelType: ::std::os::raw::c_uint,
    #[doc = "< [OUT]  \\~chinese 支持的像素格式种类    \\~english Support pixel format"]
    pub nSupportedPixelFmtNum: ::std::os::raw::c_uint,
    pub enPixelList: [::std::os::raw::c_uint; 64usize],
    pub nReserved: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_IMAGE_BASIC_INFO_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_IMAGE_BASIC_INFO_>(),
        336usize,
        concat!("Size of: ", stringify!(_MV_IMAGE_BASIC_INFO_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_IMAGE_BASIC_INFO_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_IMAGE_BASIC_INFO_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nWidthValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nWidthValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nWidthMin as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nWidthMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nWidthMax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nWidthMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nWidthInc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nWidthInc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nHeightValue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nHeightValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nHeightMin as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nHeightMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nHeightMax as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nHeightMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nHeightInc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nHeightInc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).fFrameRateValue as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(fFrameRateValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).fFrameRateMin as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(fFrameRateMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).fFrameRateMax as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(fFrameRateMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).enPixelType as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nSupportedPixelFmtNum as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nSupportedPixelFmtNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).enPixelList as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(enPixelList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_IMAGE_BASIC_INFO_>())).nReserved as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_IMAGE_BASIC_INFO_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_IMAGE_BASIC_INFO = _MV_IMAGE_BASIC_INFO_;
#[doc = "<        \\~chinese 无效值                        \\~english Invalid"]
pub const _MV_CC_BAYER_NOISE_FEATURE_TYPE_MV_CC_BAYER_NOISE_FEATURE_TYPE_INVALID:
    _MV_CC_BAYER_NOISE_FEATURE_TYPE = 0;
#[doc = "<        \\~chinese 噪声曲线                      \\~english Noise curve"]
pub const _MV_CC_BAYER_NOISE_FEATURE_TYPE_MV_CC_BAYER_NOISE_FEATURE_TYPE_PROFILE:
    _MV_CC_BAYER_NOISE_FEATURE_TYPE = 1;
#[doc = "<        \\~chinese 噪声水平                      \\~english Noise level"]
pub const _MV_CC_BAYER_NOISE_FEATURE_TYPE_MV_CC_BAYER_NOISE_FEATURE_TYPE_LEVEL:
    _MV_CC_BAYER_NOISE_FEATURE_TYPE = 2;
#[doc = "<        \\~chinese 默认值                        \\~english Default"]
pub const _MV_CC_BAYER_NOISE_FEATURE_TYPE_MV_CC_BAYER_NOISE_FEATURE_TYPE_DEFAULT:
    _MV_CC_BAYER_NOISE_FEATURE_TYPE = 1;
#[doc = " \\~chinese 噪声特性类型    \\~english Noise feature type"]
pub type _MV_CC_BAYER_NOISE_FEATURE_TYPE = ::std::os::raw::c_int;
#[doc = " \\~chinese 噪声特性类型    \\~english Noise feature type"]
pub use self::_MV_CC_BAYER_NOISE_FEATURE_TYPE as MV_CC_BAYER_NOISE_FEATURE_TYPE;
#[doc = " \\~chinese Bayer格式降噪特性信息    \\~english Denoise profile info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_BAYER_NOISE_PROFILE_INFO_T_ {
    #[doc = "<  \\~chinese 版本                           \\~english version"]
    pub nVersion: ::std::os::raw::c_uint,
    #[doc = "<  \\~chinese 噪声特性类型       \\~english noise feature type"]
    pub enNoiseFeatureType: MV_CC_BAYER_NOISE_FEATURE_TYPE,
    #[doc = "<  \\~chinese 图像格式                       \\~english image format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "<  \\~chinese 平均噪声水平                   \\~english noise level"]
    pub nNoiseLevel: ::std::os::raw::c_int,
    #[doc = "<  \\~chinese 曲线点数                       \\~english curve point number"]
    pub nCurvePointNum: ::std::os::raw::c_uint,
    #[doc = "<  \\~chinese 噪声曲线                       \\~english noise curve"]
    pub nNoiseCurve: *mut ::std::os::raw::c_int,
    #[doc = "<  \\~chinese 亮度曲线                       \\~english luminance curve"]
    pub nLumCurve: *mut ::std::os::raw::c_int,
    #[doc = "<       \\~chinese 预留                           \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_BAYER_NOISE_PROFILE_INFO_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>(),
        72usize,
        concat!("Size of: ", stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).nVersion as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(nVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).enNoiseFeatureType
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(enNoiseFeatureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).enPixelType as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).nNoiseLevel as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(nNoiseLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).nCurvePointNum
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(nCurvePointNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).nNoiseCurve as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(nNoiseCurve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).nLumCurve as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(nLumCurve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_PROFILE_INFO_T_>())).nRes as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_PROFILE_INFO_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese Bayer格式降噪特性信息    \\~english Denoise profile info"]
pub type MV_CC_BAYER_NOISE_PROFILE_INFO = _MV_CC_BAYER_NOISE_PROFILE_INFO_T_;
#[doc = " \\~chinese Bayer格式噪声估计参数    \\~english Bayer noise estimate param"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽(大于等于8)              \\~english Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高(大于等于8)              \\~english Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式                       \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存                   \\~english Input data buffer"]
    pub pSrcData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小                   \\~english Input data size"]
    pub nSrcDataLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 噪声阈值(0-4095)               \\~english Noise Threshold"]
    pub nNoiseThreshold: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 用于存储噪声曲线和亮度曲线（需要外部分配，缓存大小：4096 * sizeof(int) * 2）     \\~english Buffer used to store noise and brightness curves, size:4096 * sizeof(int) * 2)"]
    pub pCurveBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [OUT]  \\~chinese 降噪特性信息               \\~english Denoise profile"]
    pub stNoiseProfile: MV_CC_BAYER_NOISE_PROFILE_INFO,
    #[doc = "< [IN]  \\~chinese 线程数量，0表示算法库根据硬件自适应；1表示单线程（默认）；大于1表示线程数目      \\~english Thread number, 0 means that the library is adaptive to the hardware, 1 means single thread(Default value), Greater than 1 indicates the number of threads"]
    pub nThreadNum: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                           \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).nWidth as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).nHeight as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).enPixelType as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).pSrcData as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(pSrcData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).nSrcDataLen as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nSrcDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).nNoiseThreshold
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nNoiseThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).pCurveBuf as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(pCurveBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).stNoiseProfile
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(stNoiseProfile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).nThreadNum as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nThreadNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_>())).nRes as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese Bayer格式噪声估计参数    \\~english Bayer noise estimate param"]
pub type MV_CC_BAYER_NOISE_ESTIMATE_PARAM = _MV_CC_BAYER_NOISE_ESTIMATE_PARAM_T_;
#[doc = " \\~chinese Bayer格式空域降噪参数    \\~english Bayer spatial Denoise param"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽(大于等于8)              \\~english Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高(大于等于8)              \\~english Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式                       \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存                   \\~english Input data buffer"]
    pub pSrcData: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小                   \\~english Input data size"]
    pub nSrcDataLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出降噪后的数据               \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小           \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出降噪后的数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 降噪特性信息(来源于噪声估计)   \\~english Denoise profile"]
    pub stNoiseProfile: MV_CC_BAYER_NOISE_PROFILE_INFO,
    #[doc = "< [IN]  \\~chinese 降噪强度(0-100)                \\~english nDenoise Strength"]
    pub nDenoiseStrength: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 锐化强度(0-32)                 \\~english Sharpen Strength"]
    pub nSharpenStrength: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 噪声校正系数(0-1280)           \\~english Noise Correct"]
    pub nNoiseCorrect: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 线程数量，0表示算法库根据硬件自适应；1表示单线程（默认）；大于1表示线程数目         \\~english Thread number, 0 means that the library is adaptive to the hardware, 1 means single thread(Default value), Greater than 1 indicates the number of threads"]
    pub nThreadNum: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                           \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nWidth as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nHeight as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).enPixelType
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).pSrcData as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(pSrcData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nSrcDataLen
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nSrcDataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).pDstBuf as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nDstBufSize
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nDstBufLen as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).stNoiseProfile
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(stNoiseProfile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nDenoiseStrength
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nDenoiseStrength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nSharpenStrength
                as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nSharpenStrength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nNoiseCorrect
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nNoiseCorrect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nThreadNum as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nThreadNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_>())).nRes as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese Bayer格式空域降噪参数    \\~english Bayer spatial Denoise param"]
pub type MV_CC_BAYER_SPATIAL_DENOISE_PARAM = _MV_CC_BAYER_SPATIAL_DENOISE_PARAM_T_;
#[doc = " \\~chinese CLUT参数                  \\~english CLUT param"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_CLUT_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 是否启用CLUT           \\~english CLUT enable"]
    pub bCLUTEnable: bool_,
    #[doc = "< [IN]  \\~chinese 量化系数(2的整数幂,最大65536)  \\~english Quantitative scale(Integer power of 2, <= 65536)"]
    pub nCLUTScale: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese CLUT大小,[17,33]（建议值17）     \\~english CLUT size[17,33](Recommended values of 17)"]
    pub nCLUTSize: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 量化CLUT表             \\~english CLUT buffer"]
    pub pCLUTBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 量化CLUT缓存大小(nCLUTSize*nCLUTSize*nCLUTSize*sizeof(int)*3)  \\~english CLUT buffer length(nCLUTSize*nCLUTSize*nCLUTSize*sizeof(int)*3)"]
    pub nCLUTBufLen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_CLUT_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_CLUT_PARAM_T_>(),
        64usize,
        concat!("Size of: ", stringify!(_MV_CC_CLUT_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_CLUT_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_CLUT_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CLUT_PARAM_T_>())).bCLUTEnable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CLUT_PARAM_T_),
            "::",
            stringify!(bCLUTEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CLUT_PARAM_T_>())).nCLUTScale as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CLUT_PARAM_T_),
            "::",
            stringify!(nCLUTScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CLUT_PARAM_T_>())).nCLUTSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CLUT_PARAM_T_),
            "::",
            stringify!(nCLUTSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CLUT_PARAM_T_>())).pCLUTBuf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CLUT_PARAM_T_),
            "::",
            stringify!(pCLUTBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CLUT_PARAM_T_>())).nCLUTBufLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CLUT_PARAM_T_),
            "::",
            stringify!(nCLUTBufLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CLUT_PARAM_T_>())).nRes as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CLUT_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese CLUT参数                  \\~english CLUT param"]
pub type MV_CC_CLUT_PARAM = _MV_CC_CLUT_PARAM_T_;
#[doc = " \\~chinese 对比度调节结构体          \\~english Contrast structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_CONTRAST_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度(最小8)        \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度(最小8)        \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 对比度值，[1,10000]     \\~english Contrast factor,[1,10000]"]
    pub nContrastFactor: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_CONTRAST_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_CONTRAST_PARAM_T_>(),
        80usize,
        concat!("Size of: ", stringify!(_MV_CC_CONTRAST_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_CONTRAST_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_CONTRAST_PARAM_T_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nSrcBufLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).enPixelType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nDstBufSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nDstBufLen as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nContrastFactor as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nContrastFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_CONTRAST_PARAM_T_>())).nRes as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_CONTRAST_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 对比度调节结构体          \\~english Contrast structure"]
pub type MV_CC_CONTRAST_PARAM = _MV_CC_CONTRAST_PARAM_T_;
#[doc = " \\~chinese 锐化结构体                \\~english Sharpen structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_SHARPEN_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度(最小8)        \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度(最小8)        \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 锐度调节强度，[0,500]  \\~english Sharpen amount,[0,500]"]
    pub nSharpenAmount: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 锐度调节半径(半径越大，耗时越长)，[1,21]   \\~english Sharpen radius(The larger the radius, the longer it takes),[1,21]"]
    pub nSharpenRadius: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 锐度调节阈值，[0,255]  \\~english Sharpen threshold,[0,255]"]
    pub nSharpenThreshold: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_SHARPEN_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_SHARPEN_PARAM_T_>(),
        88usize,
        concat!("Size of: ", stringify!(_MV_CC_SHARPEN_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_SHARPEN_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_SHARPEN_PARAM_T_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nHeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).pSrcBuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nSrcBufLen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).enPixelType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).pDstBuf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nDstBufSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nDstBufLen as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nSharpenAmount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nSharpenAmount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nSharpenRadius as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nSharpenRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nSharpenThreshold as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nSharpenThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_SHARPEN_PARAM_T_>())).nRes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SHARPEN_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 锐化结构体                \\~english Sharpen structure"]
pub type MV_CC_SHARPEN_PARAM = _MV_CC_SHARPEN_PARAM_T_;
#[doc = " \\~chinese 色彩校正结构体            \\~english Color correct structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_COLOR_CORRECT_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度               \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度               \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 有效图像位数(8,10,12,16)   \\~english Image bit(8 or 10 or 12 or 16)"]
    pub nImageBit: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese Gamma信息              \\~english Gamma info"]
    pub stGammaParam: MV_CC_GAMMA_PARAM,
    #[doc = "< [IN]  \\~chinese CCM信息                \\~english CCM info"]
    pub stCCMParam: MV_CC_CCM_PARAM_EX,
    #[doc = "< [IN]  \\~chinese CLUT信息               \\~english CLUT info"]
    pub stCLUTParam: MV_CC_CLUT_PARAM,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_COLOR_CORRECT_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_COLOR_CORRECT_PARAM_T_>(),
        280usize,
        concat!("Size of: ", stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_COLOR_CORRECT_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nSrcBufLen as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).enPixelType as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nDstBufSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nDstBufLen as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nImageBit as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nImageBit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).stGammaParam as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(stGammaParam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).stCCMParam as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(stCCMParam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).stCLUTParam as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(stCLUTParam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_COLOR_CORRECT_PARAM_T_>())).nRes as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_COLOR_CORRECT_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 色彩校正结构体            \\~english Color correct structure"]
pub type MV_CC_COLOR_CORRECT_PARAM = _MV_CC_COLOR_CORRECT_PARAM_T_;
#[doc = " \\~chinese 矩形ROI结构体             \\~english Rect ROI structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_RECT_I_ {
    #[doc = "< \\~chinese 矩形左上角X轴坐标            \\~english X Position"]
    pub nX: ::std::os::raw::c_uint,
    #[doc = "< \\~chinese 矩形左上角Y轴坐标            \\~english Y Position"]
    pub nY: ::std::os::raw::c_uint,
    #[doc = "< \\~chinese 矩形宽度                     \\~english Rect Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< \\~chinese 矩形高度                     \\~english Rect Height"]
    pub nHeight: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__MV_CC_RECT_I_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_RECT_I_>(),
        16usize,
        concat!("Size of: ", stringify!(_MV_CC_RECT_I_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_RECT_I_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_CC_RECT_I_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECT_I_>())).nX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECT_I_),
            "::",
            stringify!(nX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECT_I_>())).nY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECT_I_),
            "::",
            stringify!(nY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECT_I_>())).nWidth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECT_I_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_RECT_I_>())).nHeight as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_RECT_I_),
            "::",
            stringify!(nHeight)
        )
    );
}
#[doc = " \\~chinese 矩形ROI结构体             \\~english Rect ROI structure"]
pub type MV_CC_RECT_I = _MV_CC_RECT_I_;
#[doc = " \\~chinese 噪声估计结构体            \\~english Noise estimate structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_NOISE_ESTIMATE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度(最小8)        \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度(最小8)        \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像ROI                \\~english Image ROI"]
    pub pstROIRect: *mut MV_CC_RECT_I,
    #[doc = "< [IN]  \\~chinese ROI个数                \\~english ROI number"]
    pub nROINum: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 噪声阈值[0,4095]       \\~english Noise threshold[0,4095]"]
    #[doc = "< \\~chinese 建议值:8bit,0xE0;10bit,0x380;12bit,0xE00     \\~english Suggestive value:8bit,0xE0;10bit,0x380;12bit,0xE00"]
    pub nNoiseThreshold: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出噪声特性           \\~english Output Noise Profile"]
    pub pNoiseProfile: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nNoiseProfileSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出噪声特性长度       \\~english Output Noise Profile length"]
    pub nNoiseProfileLen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_NOISE_ESTIMATE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>(),
        96usize,
        concat!("Size of: ", stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).enPixelType as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nSrcBufLen as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).pstROIRect as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(pstROIRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nROINum as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nROINum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nNoiseThreshold as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nNoiseThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).pNoiseProfile as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(pNoiseProfile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nNoiseProfileSize as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nNoiseProfileSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nNoiseProfileLen as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nNoiseProfileLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_NOISE_ESTIMATE_PARAM_T_>())).nRes as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_NOISE_ESTIMATE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 噪声估计结构体            \\~english Noise estimate structure"]
pub type MV_CC_NOISE_ESTIMATE_PARAM = _MV_CC_NOISE_ESTIMATE_PARAM_T_;
#[doc = " \\~chinese 空域降噪结构体            \\~english Spatial denoise structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_SPATIAL_DENOISE_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度(最小8)        \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度(最小8)        \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据大小           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出降噪后的数据       \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出降噪后的数据长度   \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入噪声特性           \\~english Input Noise Profile"]
    pub pNoiseProfile: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入噪声特性长度       \\~english Input Noise Profile length"]
    pub nNoiseProfileLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 降噪强度[0,100]        \\~english Denoise Strength[0,100]"]
    pub nBayerDenoiseStrength: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 锐化强度[0,32]         \\~english Sharpen Strength[0,32]"]
    pub nBayerSharpenStrength: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 噪声校正系数[0,1280]   \\~english Noise Correct[0,1280]"]
    pub nBayerNoiseCorrect: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 亮度校正系数[1,2000]   \\~english Noise Correct Lum[1,2000]"]
    pub nNoiseCorrectLum: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 色调校正系数[1,2000]   \\~english Noise Correct Chrom[1,2000]"]
    pub nNoiseCorrectChrom: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 亮度降噪强度[0,100]    \\~english Strength Lum[0,100]"]
    pub nStrengthLum: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 色调降噪强度[0,100]    \\~english Strength Chrom[0,100]"]
    pub nStrengthChrom: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 锐化强度[1,1000]       \\~english Strength Sharpen[1,1000]"]
    pub nStrengthSharpen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_SPATIAL_DENOISE_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>(),
        128usize,
        concat!("Size of: ", stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).enPixelType as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nSrcBufLen as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nDstBufSize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nDstBufLen as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).pNoiseProfile as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(pNoiseProfile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nNoiseProfileLen as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nNoiseProfileLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nBayerDenoiseStrength
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nBayerDenoiseStrength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nBayerSharpenStrength
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nBayerSharpenStrength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nBayerNoiseCorrect
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nBayerNoiseCorrect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nNoiseCorrectLum as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nNoiseCorrectLum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nNoiseCorrectChrom
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nNoiseCorrectChrom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nStrengthLum as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nStrengthLum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nStrengthChrom as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nStrengthChrom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nStrengthSharpen as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nStrengthSharpen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_SPATIAL_DENOISE_PARAM_T_>())).nRes as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_SPATIAL_DENOISE_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese 空域降噪结构体            \\~english Spatial denoise structure"]
pub type MV_CC_SPATIAL_DENOISE_PARAM = _MV_CC_SPATIAL_DENOISE_PARAM_T_;
#[doc = " \\~chinese LSC标定结构体             \\~english LSC calib structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_LSC_CALIB_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度[16,65535]     \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度[16-65535]     \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出标定表缓存         \\~english Output calib buffer"]
    pub pCalibBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的标定表缓冲大小(nWidth*nHeight*sizeof(unsigned short))    \\~english Provided output buffer size"]
    pub nCalibBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出标定表缓存长度     \\~english Output calib buffer length"]
    pub nCalibBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 宽度分块数             \\~english Width Sec num"]
    pub nSecNumW: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 高度分块数             \\~english Height Sec num"]
    pub nSecNumH: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 边缘填充系数[1,5]      \\~english Pad Coef[1,5]"]
    pub nPadCoef: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 标定方式(0-中心为基准;1-最亮区域为基准;2-目标亮度为基准) \\~english Calib method"]
    pub nCalibMethod: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 目标亮度(标定方式为2时有效)    \\~english Target Gray"]
    #[doc = "< \\~chinese 8位,范围：[0,255]            \\~english 8bit,range:[0,255]"]
    #[doc = "< \\~chinese 10位,范围：[0,1023]          \\~english 10bit,range:[0,1023]"]
    #[doc = "< \\~chinese 12位,范围：[0,4095]          \\~english 12bit,range:[0,4095]"]
    pub nTargetGray: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_LSC_CALIB_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_LSC_CALIB_PARAM_T_>(),
        104usize,
        concat!("Size of: ", stringify!(_MV_CC_LSC_CALIB_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_LSC_CALIB_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_LSC_CALIB_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).enPixelType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nSrcBufLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).pCalibBuf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(pCalibBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nCalibBufSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nCalibBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nCalibBufLen as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nCalibBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nSecNumW as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nSecNumW)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nSecNumH as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nSecNumH)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nPadCoef as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nPadCoef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nCalibMethod as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nCalibMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nTargetGray as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nTargetGray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_CC_LSC_CALIB_PARAM_T_>())).nRes as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CALIB_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese LSC标定结构体             \\~english LSC calib structure"]
pub type MV_CC_LSC_CALIB_PARAM = _MV_CC_LSC_CALIB_PARAM_T_;
#[doc = " \\~chinese LSC校正结构体             \\~english LSC correct structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_CC_LSC_CORRECT_PARAM_T_ {
    #[doc = "< [IN]  \\~chinese 图像宽度[16,65535]     \\~english Image Width"]
    pub nWidth: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 图像高度[16,65535]     \\~english Image Height"]
    pub nHeight: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 像素格式               \\~english Pixel format"]
    pub enPixelType: MvGvspPixelType,
    #[doc = "< [IN]  \\~chinese 输入数据缓存           \\~english Input data buffer"]
    pub pSrcBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入数据长度           \\~english Input data length"]
    pub nSrcBufLen: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据缓存           \\~english Output data buffer"]
    pub pDstBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 提供的输出缓冲区大小   \\~english Provided output buffer size"]
    pub nDstBufSize: ::std::os::raw::c_uint,
    #[doc = "< [OUT] \\~chinese 输出数据长度           \\~english Output data length"]
    pub nDstBufLen: ::std::os::raw::c_uint,
    #[doc = "< [IN]  \\~chinese 输入标定表缓存         \\~english Input calib buffer"]
    pub pCalibBuf: *mut ::std::os::raw::c_uchar,
    #[doc = "< [IN]  \\~chinese 输入标定表缓存长度     \\~english Input calib buffer length"]
    pub nCalibBufLen: ::std::os::raw::c_uint,
    #[doc = "<       \\~chinese 预留                   \\~english Reserved"]
    pub nRes: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout__MV_CC_LSC_CORRECT_PARAM_T_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_CC_LSC_CORRECT_PARAM_T_>(),
        96usize,
        concat!("Size of: ", stringify!(_MV_CC_LSC_CORRECT_PARAM_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_CC_LSC_CORRECT_PARAM_T_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_CC_LSC_CORRECT_PARAM_T_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nWidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).enPixelType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(enPixelType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).pSrcBuf as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(pSrcBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nSrcBufLen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nSrcBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).pDstBuf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(pDstBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nDstBufSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nDstBufSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nDstBufLen as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nDstBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).pCalibBuf as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(pCalibBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nCalibBufLen as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nCalibBufLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_CC_LSC_CORRECT_PARAM_T_>())).nRes as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_CC_LSC_CORRECT_PARAM_T_),
            "::",
            stringify!(nRes)
        )
    );
}
#[doc = " \\~chinese LSC校正结构体             \\~english LSC correct structure"]
pub type MV_CC_LSC_CORRECT_PARAM = _MV_CC_LSC_CORRECT_PARAM_T_;
#[doc = "< Always visible"]
pub const MV_XML_Visibility_V_Beginner: MV_XML_Visibility = 0;
#[doc = "< Visible for experts or Gurus"]
pub const MV_XML_Visibility_V_Expert: MV_XML_Visibility = 1;
#[doc = "< Visible for Gurus"]
pub const MV_XML_Visibility_V_Guru: MV_XML_Visibility = 2;
#[doc = "< Not Visible"]
pub const MV_XML_Visibility_V_Invisible: MV_XML_Visibility = 3;
#[doc = "< Object is not yet initialized"]
pub const MV_XML_Visibility_V_Undefined: MV_XML_Visibility = 99;
pub type MV_XML_Visibility = ::std::os::raw::c_int;
#[doc = " \\~chinese 单个节点基本属性 | en:Single Node Basic Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_NODE_FEATURE_ {
    #[doc = "< \\~chinese 节点类型         \\~english Node Type"]
    pub enType: MV_XML_InterfaceType,
    #[doc = "< \\~chinese 是否可见         \\~english Is visibility"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 节点描述,目前暂不支持   \\~english Node Description, NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 显示名称         \\~english Display Name"]
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 节点名           \\~english Node Name"]
    pub strName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 提示             \\~english Notice"]
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_NODE_FEATURE_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_NODE_FEATURE_>(),
        1176usize,
        concat!("Size of: ", stringify!(_MV_XML_NODE_FEATURE_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_NODE_FEATURE_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_NODE_FEATURE_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).enType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(enType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).enVisivility as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).strDescription as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).strDisplayName as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).strName as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).strToolTip as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_NODE_FEATURE_>())).nReserved as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODE_FEATURE_),
            "::",
            stringify!(nReserved)
        )
    );
}
#[doc = " \\~chinese 单个节点基本属性 | en:Single Node Basic Attributes"]
pub type MV_XML_NODE_FEATURE = _MV_XML_NODE_FEATURE_;
#[doc = " \\~chinese 节点列表 | en:Node List"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_NODES_LIST_ {
    #[doc = "< \\~chinese 节点个数             \\~english Node Number"]
    pub nNodeNum: ::std::os::raw::c_uint,
    pub stNodes: [MV_XML_NODE_FEATURE; 128usize],
}
#[test]
fn bindgen_test_layout__MV_XML_NODES_LIST_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_NODES_LIST_>(),
        150532usize,
        concat!("Size of: ", stringify!(_MV_XML_NODES_LIST_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_NODES_LIST_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_NODES_LIST_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_NODES_LIST_>())).nNodeNum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODES_LIST_),
            "::",
            stringify!(nNodeNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_NODES_LIST_>())).stNodes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_NODES_LIST_),
            "::",
            stringify!(stNodes)
        )
    );
}
#[doc = " \\~chinese 节点列表 | en:Node List"]
pub type MV_XML_NODES_LIST = _MV_XML_NODES_LIST_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Value_ {
    #[doc = "< \\~chinese 节点类型         \\~english Node Type"]
    pub enType: MV_XML_InterfaceType,
    #[doc = "< \\~chinese 节点描述,目前暂不支持   \\~english Node Description, NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 显示名称         \\~english Display Name"]
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 节点名           \\~english Node Name"]
    pub strName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 提示             \\~english Notice"]
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Value_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Value_>(),
        1172usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Value_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Value_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Value_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Value_>())).enType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Value_),
            "::",
            stringify!(enType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Value_>())).strDescription as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Value_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Value_>())).strDisplayName as *const _ as usize
        },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Value_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Value_>())).strName as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Value_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Value_>())).strToolTip as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Value_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Value_>())).nReserved as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Value_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Value = _MV_XML_FEATURE_Value_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Base_ {
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Base_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Base_>(),
        4usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Base_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Base_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Base_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Base_>())).enAccessMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Base_),
            "::",
            stringify!(enAccessMode)
        )
    );
}
pub type MV_XML_FEATURE_Base = _MV_XML_FEATURE_Base_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Integer_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub nValue: i64,
    #[doc = "< \\~chinese 最小值           \\~english Min Value"]
    pub nMinValue: i64,
    #[doc = "< \\~chinese 最大值           \\~english Max Value"]
    pub nMaxValue: i64,
    #[doc = "< \\~chinese 增量             \\~english Increment"]
    pub nIncrement: i64,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Integer_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Integer_>(),
        1216usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Integer_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Integer_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Integer_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).strName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).strDisplayName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).strDescription as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).bIsLocked as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).nValue as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(nValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).nMinValue as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(nMinValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).nMaxValue as *const _ as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(nMaxValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).nIncrement as *const _ as usize
        },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(nIncrement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Integer_>())).nReserved as *const _ as usize
        },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Integer_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Integer = _MV_XML_FEATURE_Integer_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Boolean_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub bValue: bool_,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Boolean_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Boolean_>(),
        1184usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Boolean_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Boolean_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Boolean_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).strName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).strDisplayName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).strDescription as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).bIsLocked as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).bValue as *const _ as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(bValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Boolean_>())).nReserved as *const _ as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Boolean_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Boolean = _MV_XML_FEATURE_Boolean_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Command_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Command_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Command_>(),
        1180usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Command_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Command_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Command_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).strName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).strDisplayName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).strDescription as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).bIsLocked as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Command_>())).nReserved as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Command_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Command = _MV_XML_FEATURE_Command_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Float_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub dfValue: f64,
    #[doc = "< \\~chinese 最小值           \\~english Min Value"]
    pub dfMinValue: f64,
    #[doc = "< \\~chinese 最大值           \\~english Max Value"]
    pub dfMaxValue: f64,
    #[doc = "< \\~chinese 增量             \\~english Increment"]
    pub dfIncrement: f64,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Float_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Float_>(),
        1216usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Float_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Float_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Float_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).strName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).strDisplayName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).strDescription as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).bIsLocked as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).dfValue as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(dfValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).dfMinValue as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(dfMinValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).dfMaxValue as *const _ as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(dfMaxValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).dfIncrement as *const _ as usize
        },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(dfIncrement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Float_>())).nReserved as *const _ as usize
        },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Float_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Float = _MV_XML_FEATURE_Float_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_String_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub strValue: [::std::os::raw::c_char; 64usize],
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_String_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_String_>(),
        1244usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_String_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_String_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_String_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).strName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).strDisplayName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).strDescription as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).bIsLocked as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).strValue as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(strValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_String_>())).nReserved as *const _ as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_String_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_String = _MV_XML_FEATURE_String_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Register_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub nAddrValue: i64,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Register_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Register_>(),
        1192usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Register_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Register_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Register_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).strName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).strDisplayName as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).strDescription as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).bIsLocked as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).nAddrValue as *const _ as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(nAddrValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Register_>())).nReserved as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Register_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Register = _MV_XML_FEATURE_Register_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Category_ {
    #[doc = "< \\~chinese 节点描述 目前暂不支持    \\~english Node Description, NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 显示名称         \\~english Display Name"]
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 节点名           \\~english Node Name"]
    pub strName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 提示             \\~english Notice"]
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Category_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Category_>(),
        1172usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Category_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Category_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Category_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Category_>())).strDescription as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Category_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Category_>())).strDisplayName as *const _
                as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Category_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Category_>())).strName as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Category_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Category_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Category_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Category_>())).enVisivility as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Category_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Category_>())).nReserved as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Category_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Category = _MV_XML_FEATURE_Category_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_EnumEntry_ {
    pub strName: [::std::os::raw::c_char; 64usize],
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 目前暂不支持     \\~english NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    pub bIsImplemented: ::std::os::raw::c_int,
    pub nParentsNum: ::std::os::raw::c_int,
    pub stParentsList: [MV_XML_NODE_FEATURE; 8usize],
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub nValue: i64,
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    pub nReserved: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_EnumEntry_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_EnumEntry_>(),
        10624usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_EnumEntry_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_EnumEntry_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_EnumEntry_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).strName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).strDisplayName as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).strDescription as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).strToolTip as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).bIsImplemented as *const _
                as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(bIsImplemented)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).nParentsNum as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(nParentsNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).stParentsList as *const _
                as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(stParentsList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).enVisivility as *const _ as usize
        },
        10568usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).nValue as *const _ as usize
        },
        10576usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(nValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).enAccessMode as *const _ as usize
        },
        10584usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).bIsLocked as *const _ as usize
        },
        10588usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_EnumEntry_>())).nReserved as *const _ as usize
        },
        10592usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_EnumEntry_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_EnumEntry = _MV_XML_FEATURE_EnumEntry_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Enumeration_ {
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 节点描述 目前暂不支持    \\~english Node Description, NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 显示名称         \\~english Display Name"]
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 节点名           \\~english Node Name"]
    pub strName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 提示             \\~english Notice"]
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese ymbolic数        \\~english Symbolic Number"]
    pub nSymbolicNum: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前Symbolic索引    \\~english Current Symbolic Index"]
    pub strCurrentSymbolic: [::std::os::raw::c_char; 64usize],
    pub strSymbolic: [[::std::os::raw::c_char; 64usize]; 64usize],
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    #[doc = "< \\~chinese 当前值           \\~english Current Value"]
    pub nValue: i64,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Enumeration_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Enumeration_>(),
        5352usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Enumeration_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Enumeration_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Enumeration_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).enVisivility as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).strDescription as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).strDisplayName as *const _
                as usize
        },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).strName as *const _ as usize
        },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).strToolTip as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).nSymbolicNum as *const _
                as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(nSymbolicNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).strCurrentSymbolic as *const _
                as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(strCurrentSymbolic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).strSymbolic as *const _
                as usize
        },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(strSymbolic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).enAccessMode as *const _
                as usize
        },
        5320usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).bIsLocked as *const _ as usize
        },
        5324usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).nValue as *const _ as usize
        },
        5328usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(nValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Enumeration_>())).nReserved as *const _ as usize
        },
        5336usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Enumeration_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Enumeration = _MV_XML_FEATURE_Enumeration_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MV_XML_FEATURE_Port_ {
    #[doc = "< \\~chinese 是否可见         \\~english Visible"]
    pub enVisivility: MV_XML_Visibility,
    #[doc = "< \\~chinese 节点描述,目前暂不支持    \\~english Node Description, NOT SUPPORT NOW"]
    pub strDescription: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 显示名称         \\~english Display Name"]
    pub strDisplayName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 节点名           \\~english Node Name"]
    pub strName: [::std::os::raw::c_char; 64usize],
    #[doc = "< \\~chinese 提示             \\~english Notice"]
    pub strToolTip: [::std::os::raw::c_char; 512usize],
    #[doc = "< \\~chinese 访问模式         \\~english Access Mode"]
    pub enAccessMode: MV_XML_AccessMode,
    #[doc = "< \\~chinese 是否锁定。0-否；1-是,目前暂不支持    \\~english Locked. 0-NO; 1-YES, NOT SUPPORT NOW"]
    pub bIsLocked: ::std::os::raw::c_int,
    pub nReserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__MV_XML_FEATURE_Port_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_FEATURE_Port_>(),
        1180usize,
        concat!("Size of: ", stringify!(_MV_XML_FEATURE_Port_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_FEATURE_Port_>(),
        4usize,
        concat!("Alignment of ", stringify!(_MV_XML_FEATURE_Port_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).enVisivility as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(enVisivility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).strDescription as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(strDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).strDisplayName as *const _ as usize
        },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(strDisplayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).strName as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(strName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).strToolTip as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(strToolTip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).enAccessMode as *const _ as usize
        },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(enAccessMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).bIsLocked as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(bIsLocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_FEATURE_Port_>())).nReserved as *const _ as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_FEATURE_Port_),
            "::",
            stringify!(nReserved)
        )
    );
}
pub type MV_XML_FEATURE_Port = _MV_XML_FEATURE_Port_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MV_XML_CAMERA_FEATURE_ {
    pub enType: MV_XML_InterfaceType,
    pub SpecialFeature: _MV_XML_CAMERA_FEATURE___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MV_XML_CAMERA_FEATURE___bindgen_ty_1 {
    pub stIntegerFeature: MV_XML_FEATURE_Integer,
    pub stFloatFeature: MV_XML_FEATURE_Float,
    pub stEnumerationFeature: MV_XML_FEATURE_Enumeration,
    pub stStringFeature: MV_XML_FEATURE_String,
}
#[test]
fn bindgen_test_layout__MV_XML_CAMERA_FEATURE___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_CAMERA_FEATURE___bindgen_ty_1>(),
        5352usize,
        concat!(
            "Size of: ",
            stringify!(_MV_XML_CAMERA_FEATURE___bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_CAMERA_FEATURE___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MV_XML_CAMERA_FEATURE___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_CAMERA_FEATURE___bindgen_ty_1>())).stIntegerFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_CAMERA_FEATURE___bindgen_ty_1),
            "::",
            stringify!(stIntegerFeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_CAMERA_FEATURE___bindgen_ty_1>())).stFloatFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_CAMERA_FEATURE___bindgen_ty_1),
            "::",
            stringify!(stFloatFeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_CAMERA_FEATURE___bindgen_ty_1>())).stEnumerationFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_CAMERA_FEATURE___bindgen_ty_1),
            "::",
            stringify!(stEnumerationFeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_CAMERA_FEATURE___bindgen_ty_1>())).stStringFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_CAMERA_FEATURE___bindgen_ty_1),
            "::",
            stringify!(stStringFeature)
        )
    );
}
#[test]
fn bindgen_test_layout__MV_XML_CAMERA_FEATURE_() {
    assert_eq!(
        ::std::mem::size_of::<_MV_XML_CAMERA_FEATURE_>(),
        5360usize,
        concat!("Size of: ", stringify!(_MV_XML_CAMERA_FEATURE_))
    );
    assert_eq!(
        ::std::mem::align_of::<_MV_XML_CAMERA_FEATURE_>(),
        8usize,
        concat!("Alignment of ", stringify!(_MV_XML_CAMERA_FEATURE_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MV_XML_CAMERA_FEATURE_>())).enType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_CAMERA_FEATURE_),
            "::",
            stringify!(enType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MV_XML_CAMERA_FEATURE_>())).SpecialFeature as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MV_XML_CAMERA_FEATURE_),
            "::",
            stringify!(SpecialFeature)
        )
    );
}
pub type MV_XML_CAMERA_FEATURE = _MV_XML_CAMERA_FEATURE_;
extern "C" {
    #[doc = "  @fn     MV_CC_GetImageInfo"]
    #[doc = "  @brief  获取图像基本信息"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstInfo                     [IN][OUT]       返回给调用者有关相机图像基本信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CC_GetImageInfo"]
    #[doc = "  @brief  Get basic information of image"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstInfo                     [IN][OUT]       Structure pointer of image basic information"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_GetImageInfo(
        handle: *mut ::std::os::raw::c_void,
        pstInfo: *mut MV_IMAGE_BASIC_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CC_GetTlProxy"]
    #[doc = "  @brief  获取GenICam代理"]
    #[doc = "  @param  handle                 [IN]           句柄地址"]
    #[doc = "  @return GenICam代理类指针 ，正常返回值非NULL；异常返回NULL"]
    #[doc = ""]
    #[doc = "  @fn     MV_CC_GetTlProxy"]
    #[doc = "  @brief  Get GenICam proxy"]
    #[doc = "  @param  handle                 [IN]           Handle address"]
    #[doc = "  @return GenICam proxy pointer, normal, return non-NULL; exception, return NULL"]
    pub fn MV_CC_GetTlProxy(handle: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  @fn         MV_XML_GetRootNode"]
    #[doc = "  @brief      获取根节点"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       pstNode                [OUT]         根节点信息结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_XML_GetRootNode"]
    #[doc = "  @brief      Get root node"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       pstNode                [OUT]         Root node information structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_XML_GetRootNode(
        handle: *mut ::std::os::raw::c_void,
        pstNode: *mut MV_XML_NODE_FEATURE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_XML_GetChildren"]
    #[doc = "  @brief      从xml中获取指定节点的所有子节点，根节点为Root"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       pstNode                [IN]          根节点信息结构体"]
    #[doc = "  @param       pstNodesList           [OUT]         节点列表结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_XML_GetChildren"]
    #[doc = "  @brief      Get all children node of specific node from xml, root node is Root"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       pstNode                [IN]          Root node information structure"]
    #[doc = "  @param       pstNodesList           [OUT]         Node information structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_XML_GetChildren(
        handle: *mut ::std::os::raw::c_void,
        pstNode: *mut MV_XML_NODE_FEATURE,
        pstNodesList: *mut MV_XML_NODES_LIST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_XML_GetNodeFeature"]
    #[doc = "  @brief      获得当前节点的属性"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       pstNode                [IN]          根节点信息结构体"]
    #[doc = "  @param       pstFeature             [OUT]         当前节点属性结构体，"]
    #[doc = "pstFeature 具体结构体内容参考 MV_XML_FEATURE_x"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_XML_GetNodeFeature"]
    #[doc = "  @brief      Get current node feature"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       pstNode                [IN]          Root node information structure"]
    #[doc = "  @param       pstFeature             [OUT]         Current node feature structure"]
    #[doc = "Details of pstFeature refer to MV_XML_FEATURE_x"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_XML_GetNodeFeature(
        handle: *mut ::std::os::raw::c_void,
        pstNode: *mut MV_XML_NODE_FEATURE,
        pstFeature: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_XML_UpdateNodeFeature"]
    #[doc = "  @brief      更新节点"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       enType                 [IN]          节点类型"]
    #[doc = "  @param       pstFeature             [OUT]         当前节点属性结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_XML_UpdateNodeFeature"]
    #[doc = "  @brief      Update node"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       enType                 [IN]          Node type"]
    #[doc = "  @param       pstFeature             [OUT]         Current node feature structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_XML_UpdateNodeFeature(
        handle: *mut ::std::os::raw::c_void,
        enType: MV_XML_InterfaceType,
        pstFeature: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_XML_RegisterUpdateCallBack"]
    #[doc = "  @brief      注册更新回调"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       cbUpdate               [IN]          回调函数指针"]
    #[doc = "  @param       pUser                  [IN]          用户自定义变量"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_XML_RegisterUpdateCallBack"]
    #[doc = "  @brief      Register update callback"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       cbUpdate               [IN]          Callback function pointer"]
    #[doc = "  @param       pUser                  [IN]          User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_XML_RegisterUpdateCallBack(
        handle: *mut ::std::os::raw::c_void,
        cbUpdate: ::std::option::Option<
            unsafe extern "C" fn(
                enType: MV_XML_InterfaceType,
                pstFeature: *mut ::std::os::raw::c_void,
                pstNodesList: *mut MV_XML_NODES_LIST,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_CC_GetOneFrame"]
    #[doc = "  @brief      获取一帧图像，此函数为查询式获取，每次调用查询内部缓存有"]
    #[doc = "无数据，有数据则范围数据，无数据返回错误码"]
    #[doc = "（该接口已弃用，建议改用 MV_CC_GetOneFrameTimeOut接口）"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       pData                  [OUT]         图像数据接收指针"]
    #[doc = "  @param       nDataSize              [IN]          接收缓存大小"]
    #[doc = "  @param       pFrameInfo             [OUT]         图像信息结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_CC_GetOneFrame"]
    #[doc = "  @brief      Get one frame data, this function is using query to get data,"]
    #[doc = "query whether the internal cache has data, return data if there has, return error code if no data"]
    #[doc = "(This interface is abandoned, it is recommended to use the MV_CC_GetOneFrameTimeOut)"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       pData                  [OUT]         Recevied image data pointer"]
    #[doc = "  @param       nDataSize              [IN]          Recevied buffer size"]
    #[doc = "  @param       pFrameInfo             [OUT]         Image information structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_GetOneFrame(
        handle: *mut ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_uchar,
        nDataSize: ::std::os::raw::c_uint,
        pFrameInfo: *mut MV_FRAME_OUT_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_CC_GetOneFrameEx"]
    #[doc = "  @brief      获取一帧trunck数据，此函数为查询式获取，每次调用查询内部"]
    #[doc = "缓存有无数据，有数据则范围数据，无数据返回错误码"]
    #[doc = "（该接口已弃用，建议改用 MV_CC_GetOneFrameTimeOut接口）"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       pData                  [OUT]         图像数据接收指针"]
    #[doc = "  @param       nDataSize              [IN]          接收缓存大小"]
    #[doc = "  @param       pFrameInfo             [OUT]         图像信息结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_CC_GetOneFrameEx"]
    #[doc = "  @brief      Get one frame of trunck data, this function is using query to get data,"]
    #[doc = "query whether the internal cache has data, return data if there has, return error code if no data"]
    #[doc = "(This interface is abandoned, it is recommended to use the MV_CC_GetOneFrameTimeOut)"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       pData                  [OUT]         Recevied image data pointer"]
    #[doc = "  @param       nDataSize              [IN]          Recevied buffer size"]
    #[doc = "  @param       pFrameInfo             [OUT]         Image information structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_GetOneFrameEx(
        handle: *mut ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_uchar,
        nDataSize: ::std::os::raw::c_uint,
        pFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_CC_RegisterImageCallBack"]
    #[doc = "  @brief      注册图像数据回调（该接口已弃用，建议改用 MV_CC_RegisterImageCallBackEx接口）"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       cbOutput               [IN]          回调函数指针"]
    #[doc = "  @param       pUser                  [IN]          用户自定义变量"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_CC_RegisterImageCallBack"]
    #[doc = "  @brief      Register image data callback (This interface is abandoned, it is recommended to use the MV_CC_RegisterImageCallBackEx)"]
    #[doc = "  @param       handle                 [IN]          Handle"]
    #[doc = "  @param       cbOutput               [IN]          Callback function pointer"]
    #[doc = "  @param       pUser                  [IN]          User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_RegisterImageCallBack(
        handle: *mut ::std::os::raw::c_void,
        cbOutput: ::std::option::Option<
            unsafe extern "C" fn(
                pData: *mut ::std::os::raw::c_uchar,
                pFrameInfo: *mut MV_FRAME_OUT_INFO,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CC_SaveImage"]
    #[doc = "  @brief  保存图片（该接口已弃用，建议改用 MV_CC_SaveImageEx2接口）"]
    #[doc = "  @param  pSaveParam             [IN][OUT]          保存图片参数结构体"]
    #[doc = "pData;              // [IN]     输入数据缓存"]
    #[doc = "nDataLen;           // [IN]     输入数据大小"]
    #[doc = "enPixelType;        // [IN]     输入数据的像素格式"]
    #[doc = "nWidth;             // [IN]     图像宽"]
    #[doc = "nHeight;            // [IN]     图像高"]
    #[doc = "pImageBuffer;       // [OUT]    输出图片缓存"]
    #[doc = "nImageLen;          // [OUT]    输出图片大小"]
    #[doc = "nBufferSize;        // [IN]     提供的输出缓冲区大小"]
    #[doc = "enImageType;        // [IN]     输出图片格式"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CC_SaveImage"]
    #[doc = "  @brief  Save image (This interface is abandoned, it is recommended to use the MV_CC_SaveImageEx)"]
    #[doc = "  @param  pSaveParam             [IN][OUT]          Save image parameters structure"]
    #[doc = "pData;              // [IN]     Input data buffer"]
    #[doc = "nDataLen;           // [IN]     Input data size"]
    #[doc = "enPixelType;        // [IN]     Input data pixel format"]
    #[doc = "nWidth;             // [IN]     Width"]
    #[doc = "nHeight;            // [IN]     Height"]
    #[doc = "pImageBuffer;       // [OUT]    Output image buffer"]
    #[doc = "nImageLen;          // [OUT]    Output image size"]
    #[doc = "nBufferSize;        // [IN]     Provided output buffer size"]
    #[doc = "enImageType;        // [IN]     Output image type"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_SaveImage(pSaveParam: *mut MV_SAVE_IMAGE_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CC_SaveImageEx"]
    #[doc = "  @brief  保存图片，支持Bmp和Jpeg.编码质量在50-99之前 （该接口已弃用，建议改用 MV_CC_SaveImageEx2接口）"]
    #[doc = "  @param  pSaveParam             [IN][OUT]          保存图片参数结构体"]
    #[doc = "pData;              // [IN]     输入数据缓存"]
    #[doc = "nDataLen;           // [IN]     输入数据大小"]
    #[doc = "enPixelType;        // [IN]     输入数据的像素格式"]
    #[doc = "nWidth;             // [IN]     图像宽"]
    #[doc = "nHeight;            // [IN]     图像高"]
    #[doc = "pImageBuffer;       // [OUT]    输出图片缓存"]
    #[doc = "nImageLen;          // [OUT]    输出图片大小"]
    #[doc = "nBufferSize;        // [IN]     提供的输出缓冲区大小"]
    #[doc = "enImageType;        // [IN]     输出图片格式"]
    #[doc = "nJpgQuality;        // [IN]     编码质量, (50-99]"]
    #[doc = "nReserved[4];"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CC_SaveImageEx"]
    #[doc = "  @brief  Save image, support Bmp and Jpeg. Encoding quality, (50-99]"]
    #[doc = "  @param  pSaveParam             [IN][OUT]           Save image parameters structure"]
    #[doc = "pData;              // [IN]     Input data buffer"]
    #[doc = "nDataLen;           // [IN]     Input data size"]
    #[doc = "enPixelType;        // [IN]     Pixel format of input data"]
    #[doc = "nWidth;             // [IN]     Image width"]
    #[doc = "nHeight;            // [IN]     Image height"]
    #[doc = "pImageBuffer;       // [OUT]    Output image buffer"]
    #[doc = "nImageLen;          // [OUT]    Output image size"]
    #[doc = "nBufferSize;        // [IN]     Output buffer size provided"]
    #[doc = "enImageType;        // [IN]     Output image format"]
    #[doc = "nJpgQuality;        // [IN]     Encoding quality, (50-99]"]
    #[doc = "nReserved[4];"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_SaveImageEx(pSaveParam: *mut MV_SAVE_IMAGE_PARAM_EX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  Bayer噪声估计（该接口已弃用，建议改用ISP Tool方式进行标定）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstNoiseEstimateParam       [IN][OUT]       Bayer噪声估计参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口只支持Bayer8/Bayer10/Bayer12格式,其它Bayer格式需先转成Bayer8/Bayer10/Bayer12格式。\\n"]
    #[doc = "该接口只有在打开我司特定彩色相机后才可以正常使用，当相机被断开或者掉线后，继续使用该接口会报错。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Noise estimate of Bayer format"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstNoiseEstimateParam       [IN][OUT]       Noise estimate parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API only support Bayer8/Bayer10/Bayer12 format, other Bayer format must Convert to Bayer8/Bayer10/Bayer12 format.\\n"]
    #[doc = "This API is only available when the camera is turned on, and when the camera is disconnected or disconnected, continuing to use This API will return an error."]
    pub fn MV_CC_BayerNoiseEstimate(
        handle: *mut ::std::os::raw::c_void,
        pstNoiseEstimateParam: *mut MV_CC_BAYER_NOISE_ESTIMATE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  Bayer空域降噪（该接口已弃用，建议改用ISP Tool方式进行降噪）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstSpatialDenoiseParam      [IN][OUT]       Bayer空域降噪参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口只支持Bayer8/Bayer10/Bayer12格式,其它Bayer格式需先转成Bayer8/Bayer10/Bayer12格式。\\n"]
    #[doc = "该接口只有在打开我司特定彩色相机后才可以正常使用，当相机被断开或者掉线后，继续使用该接口会报错。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Spatial Denoise of Bayer format"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstSpatialDenoiseParam      [IN][OUT]       Spatial Denoise parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API only support Bayer8/Bayer10/Bayer12 format, other Bayer format must Convert to Bayer8/Bayer10/Bayer12 format.\\n"]
    #[doc = "This API is only available when the camera is turned on, and when the camera is disconnected or disconnected, continuing to use This API will return an error."]
    pub fn MV_CC_BayerSpatialDenoise(
        handle: *mut ::std::os::raw::c_void,
        pstSpatialDenoiseParam: *mut MV_CC_BAYER_SPATIAL_DENOISE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Bayer格式的CLUT使能和信息（该接口已弃用，建议改用ISP Tool方式进行设置）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstCLUTParam                [IN]            CLUT参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 开启CLUT并设置CLUT信息后，在调用MV_CC_ConvertPixelType、MV_CC_SaveImageEx2接口将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set CLUT param"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstCLUTParam                [IN]            CLUT parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After enable the CLUT and set CLUT, It work in the calling MV_CC_ConvertPixelType\\MV_CC_SaveImageEx2 API convert Bayer8/10/12/16 to RGB24/48， RGBA32/64，BGR24/48，BGRA32/64."]
    pub fn MV_CC_SetBayerCLUTParam(
        handle: *mut ::std::os::raw::c_void,
        pstCLUTParam: *mut MV_CC_CLUT_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  图像对比度调节（该接口已弃用，建议改用ISP Tool方式进行调节）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstContrastParam            [IN]            对比度调节参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Adjust image contrast"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstContrastParam            [IN]            Contrast parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_ImageContrast(
        handle: *mut ::std::os::raw::c_void,
        pstContrastParam: *mut MV_CC_CONTRAST_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  图像锐化（该接口已弃用，建议改用ISP Tool方式进行锐化）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstSharpenParam             [IN]            锐化参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Image sharpen"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstSharpenParam             [IN]            Sharpen parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_ImageSharpen(
        handle: *mut ::std::os::raw::c_void,
        pstSharpenParam: *mut MV_CC_SHARPEN_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  色彩校正（包括CCM和CLUT）（该接口已弃用，建议改用ISP Tool方式进行校正）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstColorCorrectParam        [IN]            色彩校正参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口支持单独CCM或者CLUT，也支持同时进行CCM和CLUT，用户可以通过CCM和CLUT信息中的使能开关进行选择。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Color Correct(include CCM and CLUT)"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstColorCorrectParam        [IN]            Color Correct parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API supports CCM or CLUT alone, as well as CCM and CLUT at the same time. The user can select by means of the enable switch in CCM and CLUT information."]
    pub fn MV_CC_ColorCorrect(
        handle: *mut ::std::os::raw::c_void,
        pstColorCorrectParam: *mut MV_CC_COLOR_CORRECT_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  噪声估计（该接口已弃用，建议改用ISP Tool方式进行标定）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstNoiseEstimateParam       [IN]            噪声估计参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 如果用户选择全图做噪声估计，nROINum可输入0，pstROIRect可置空。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Noise Estimate"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstNoiseEstimateParam       [IN]            Noise Estimate parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks If the user selects the full image, nROINum can be typed with 0 and pstROIRect empty."]
    pub fn MV_CC_NoiseEstimate(
        handle: *mut ::std::os::raw::c_void,
        pstNoiseEstimateParam: *mut MV_CC_NOISE_ESTIMATE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  空域降噪（该接口已弃用，建议改用ISP Tool方式进行降噪）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstSpatialDenoiseParam      [IN]            空域降噪参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Spatial Denoise"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstSpatialDenoiseParam      [IN]            Spatial Denoise parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_SpatialDenoise(
        handle: *mut ::std::os::raw::c_void,
        pstSpatialDenoiseParam: *mut MV_CC_SPATIAL_DENOISE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  LSC标定"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstLSCCalibParam            [IN]            标定参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  LSC Calib"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstLSCCalibParam            [IN]            LSC Calib parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_LSCCalib(
        handle: *mut ::std::os::raw::c_void,
        pstLSCCalibParam: *mut MV_CC_LSC_CALIB_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  LSC校正"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstLSCCorrectParam          [IN]            校正参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  LSC Correct"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstLSCCorrectParam          [IN]            LSC Correct parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_LSCCorrect(
        handle: *mut ::std::os::raw::c_void,
        pstLSCCorrectParam: *mut MV_CC_LSC_CORRECT_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_GIGE_ForceIp"]
    #[doc = "  @brief  强制IP（该接口已弃用，建议改用 MV_GIGE_ForceIpEx接口）"]
    #[doc = "  @param  handle：设备句柄"]
    #[doc = "  @param  nIP               [IN]      设置的IP"]
    #[doc = "  @return 见返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_GIGE_ForceIp"]
    #[doc = "  @brief  Force IP (This interface is abandoned, it is recommended to use the MV_GIGE_ForceIpEx)"]
    #[doc = "  @param  handle Handle"]
    #[doc = "  @param  nIP               [IN]      IP to set"]
    #[doc = "  @return Refer to error code"]
    pub fn MV_GIGE_ForceIp(
        handle: *mut ::std::os::raw::c_void,
        nIP: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CC_RegisterEventCallBack"]
    #[doc = "  @brief  注册事件回调（该接口已弃用，建议改用 MV_CC_RegisterEventCallBackEx接口）"]
    #[doc = "  @param  handle：设备句柄"]
    #[doc = "  @param  cbEvent           [IN]      事件回调函数指针"]
    #[doc = "  @param  pUser             [IN]      用户自定义变量"]
    #[doc = "  @return 见返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CC_RegisterEventCallBack"]
    #[doc = "  @brief  Register event callback (this interface has been deprecated and is recommended to be converted to the MV_CC_RegisterEventCallBackEx interface)"]
    #[doc = "  @param  handle：设备句柄"]
    #[doc = "  @param  cbEvent           [IN]      event callback pointer"]
    #[doc = "  @param  pUser             [IN]      User defined value"]
    #[doc = "  @return 见返回错误码"]
    pub fn MV_CC_RegisterEventCallBack(
        handle: *mut ::std::os::raw::c_void,
        cbEvent: ::std::option::Option<
            unsafe extern "C" fn(
                nExternalEventId: ::std::os::raw::c_uint,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn         MV_CC_Display"]
    #[doc = "  @brief      显示图像，注册显示窗口，内部自动显示（与MV_CC_GetImageBuffer不能同时使用，建议改用MV_CC_DisplayOneFrame接口）"]
    #[doc = "  @param       handle                 [IN]          句柄"]
    #[doc = "  @param       hWnd                   [IN]          显示窗口句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @fn         MV_CC_Display"]
    #[doc = "  @brief      Display one frame image, register display window, automatic display internally"]
    #[doc = "  @param      handle                 [IN]          Handle"]
    #[doc = "  @param      hWnd                   [IN]          Display Window Handle"]
    #[doc = "  @return     Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_Display(
        handle: *mut ::std::os::raw::c_void,
        hWnd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetIntValue(IN void* handle,"]
    #[doc = "IN const char* strKey,"]
    #[doc = "OUT MVCC_INTVALUE *pIntValue);"]
    #[doc = "  @brief  获取Integer属性值（建议改用MV_CC_GetIntValueEx接口）"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  char* strKey                [IN]        属性键值，如获取宽度信息则为\"Width\""]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机属性结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetIntValue(IN void* handle,"]
    #[doc = "IN const char* strKey,"]
    #[doc = "OUT MVCC_INTVALUE *pIntValue);"]
    #[doc = "  @brief  Get Integer value"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  char* strKey                [IN]        Key value, for example, using \"Width\" to get width"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of camera features"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_GetIntValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        pIntValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetIntValue(IN void* handle,"]
    #[doc = "IN const char* strKey,"]
    #[doc = "IN unsigned int nValue);"]
    #[doc = "  @brief  设置Integer型属性值（建议改用MV_CC_SetIntValueEx接口）"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  char* strKey                [IN]        属性键值，如获取宽度信息则为\"Width\""]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的相机的属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetIntValue(IN void* handle,"]
    #[doc = "IN const char* strKey,"]
    #[doc = "IN unsigned int nValue);"]
    #[doc = "  @brief  Set Integer value"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  char* strKey                [IN]        Key value, for example, using \"Width\" to set width"]
    #[doc = "          const unsigned int nValue   [IN]        Feature value to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_SetIntValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetWidth(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取图像宽度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机宽度的信息结构体指针"]
    #[doc = "          返回的pstValue结构体的意义"]
    #[doc = "                  unsigned int    nCurValue;      // 代表相机当前的宽度值"]
    #[doc = "                  unsigned int    nMax;           // 表示相机允许的最大可设置的宽度值"]
    #[doc = "                  unsigned int    nMin;           // 表示相机允许的最小可设置的宽度值"]
    #[doc = "                  unsigned int    nInc;           // 表示相机设置的宽度增量必须是nInc的倍数，否则无效"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "          其他整型结构体参数的接口可参照此接口"]
    #[doc = ""]
    #[doc = " @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetWidth(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get image width"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          MVCC_INTVALUE* pstValue     [IN][OUT]   Returns the information structure pointer about the camera's width for the caller"]
    #[doc = "          The meaning of returns pstValue structure"]
    #[doc = "                  unsigned int    nCurValue;      // Represents the current width value of the camera"]
    #[doc = "                  unsigned int    nMax;           // Indicates the maximum settable width value allowed by the camera"]
    #[doc = "                  unsigned int    nMin;           // Indicates the minimum settable width value allowed by the camera"]
    #[doc = "                  unsigned int    nInc;           // Indicates that the width increment set by the camera must be a multiple of nInc, otherwise it is invalid"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Other Integer structure parameters interface can refer to this interface"]
    pub fn MV_CC_GetWidth(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetWidth(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置图像宽度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的相机宽度的值,注意此宽度值必须是MV_CC_GetWidth接口返回的pstValue中的nInc的倍数才能设置成功"]
    #[doc = "  @return 成功,返回MV_OK,并且相机宽度将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = " @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetWidth(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set image width"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        To set the value of the camera width, note that the width value must be a multiple of nInc in the pstValue returned by the MV_CC_GetWidth interface"]
    #[doc = "  @return Success, return MV_OK, and the camera width will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetWidth(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetHeight(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取图像高度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机高度的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并将高度信息返回到结构体中，失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetHeight(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get image height"]
    #[doc = "  @param  void* handle                [IN]        Camera handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Return pointer of information structure related to camera height to user"]
    #[doc = "  @return Success, return MV_OK, and return height information to the structure. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetHeight(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetHeight(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置图像高度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的相机宽度的值,注意此宽度值必须是MV_CC_GetWidth接口返回的pstValue中的nInc的倍数才能设置成功"]
    #[doc = "  @return 成功,返回MV_OK,并且相机高度将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetHeight(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set image height"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Camera height value to set, note that this value must be times of nInc of pstValue returned by MV_CC_GetWidth"]
    #[doc = "  @return Success, return MV_OK, and the camera height will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetHeight(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetX(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取图像X偏移"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机X偏移的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetX(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get image X offset"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Return pointer of information structure related to camera X offset to user"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetAOIoffsetX(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetX(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置图像AOI偏移"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的相机AOI的值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机AOI偏移将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetX(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set image X offset"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Camera X offset value to set"]
    #[doc = "  @return Success, return MV_OK, and the camera X offset will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetAOIoffsetX(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetY(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取图像Y偏移"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机Y偏移的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetY(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get image Y offset"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Return pointer of information structure related to camera Y offset to user"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetAOIoffsetY(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetX(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置图像AOI偏移"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的相机AOI的值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机AOI偏移将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetY(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set image Y offset"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Camera Y offset value to set"]
    #[doc = "  @return Success, return MV_OK, and the camera Y offset will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetAOIoffsetY(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeLower(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取曝光下限"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机曝光值下限结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeLower(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get exposure lower limit"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Return pointer of information structure related to camera exposure lower to user"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetAutoExposureTimeLower(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeLower(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置曝光值下限"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的曝光值下限"]
    #[doc = "  @return 成功,返回MV_OK,并且相机曝光下限将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeLower(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set exposure lower limit"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Exposure lower to set"]
    #[doc = "  @return Success, return MV_OK, and the camera exposure time lower limit value will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetAutoExposureTimeLower(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeUpper(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取曝光上限"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机曝光值上限结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeUpper(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get exposure upper limit"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Return pointer of information structure related to camera exposure upper to user"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetAutoExposureTimeUpper(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeUpper(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置曝光值上限"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的曝光值上限"]
    #[doc = "  @return 成功,返回MV_OK,并且相机曝光上限将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeUpper(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set exposure upper limit"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Exposure upper to set"]
    #[doc = "  @return Success, return MV_OK, and the camera exposure time upper limit value will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetAutoExposureTimeUpper(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBrightness(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取亮度值"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机亮度结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBrightness(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get brightness"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Return pointer of information structure related to camera brightness to user"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetBrightness(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBrightness(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置亮度值"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的亮度值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机亮度将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBrightness(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set brightness"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Brightness upper to set"]
    #[doc = "  @return Success, return MV_OK, and the camera brightness value will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetBrightness(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetFrameRate(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  获取帧率"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   返回给调用者有关相机帧率的信息结构体指针"]
    #[doc = "          返回的pstValue结构体的意义"]
    #[doc = "                                      float           fCurValue;      // 表示相机当前的帧率"]
    #[doc = "                                      float           fMax;           // 表示相机允许设置的最大帧率"]
    #[doc = "                                      float           fMin;           // 表示相机允许设置的最小帧率"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "          其他浮点型结构体参数的接口可参照此接口"]
    #[doc = ""]
    #[doc = " @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetFrameRate(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  Get Frame Rate"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   Return pointer of information structure related to camera frame rate to user"]
    #[doc = "          The meaning of returns pstValue structure"]
    #[doc = "                                      float           fCurValue;      // Indicates the current frame rate of the camera"]
    #[doc = "                                      float           fMax;           // Indicates the maximum frame rate allowed by the camera"]
    #[doc = "                                      float           fMin;           // Indicates the minimum frame rate allowed by the camera"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Other interface of Float structure parameters can refer to this interface"]
    pub fn MV_CC_GetFrameRate(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_FLOATVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetFrameRate(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  设置帧率"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const float fValue          [IN]        想要设置的相机帧率"]
    #[doc = "  @return 成功,返回MV_OK,并且相机帧率将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = " @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetFrameRate(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  Set frame rate"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const float fValue          [IN]        Camera frame rate to set"]
    #[doc = "  @return Success, return MV_OK, and camera frame rate will be changed to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetFrameRate(
        handle: *mut ::std::os::raw::c_void,
        fValue: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGain(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  获取增益"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   返回给调用者有关相机增益的信息结构体指针"]
    #[doc = "          返回的pstValue结构体的意义"]
    #[doc = "                                      float           fCurValue;      // 表示相机当前的帧率"]
    #[doc = "                                      float           fMax;           // 表示相机允许设置的最大帧率"]
    #[doc = "                                      float           fMin;           // 表示相机允许设置的最小帧率"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "          其他浮点型结构体参数的接口可参照此接口"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGain(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  Get Gain"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   Return pointer of information structure related to gain to user"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = "                                      float           fCurValue;      // Camera current gain"]
    #[doc = "                                      float           fMax;           // The maximum gain camera allowed"]
    #[doc = "                                      float           fMin;           // The minimum gain camera allowed"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Other interface of Float structure parameters can refer to this interface"]
    pub fn MV_CC_GetGain(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_FLOATVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGain(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  设置帧率"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const float fValue          [IN]        想要设置的相机帧率"]
    #[doc = "  @return 成功,返回MV_OK,并且相机帧率将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGain(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  Set Gain"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const float fValue          [IN]        Gain value to set"]
    #[doc = "  @return Success, return MV_OK, and the camera gain value will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetGain(handle: *mut ::std::os::raw::c_void, fValue: f32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetExposureTime(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  获取曝光时间"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   返回给调用者有关相机曝光时间的信息结构体指针"]
    #[doc = "          返回的pstValue结构体的意义"]
    #[doc = "                                      float           fCurValue;      // 表示相机当前的帧率"]
    #[doc = "                                      float           fMax;           // 表示相机允许设置的最大帧率"]
    #[doc = "                                      float           fMin;           // 表示相机允许设置的最小帧率"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "          其他浮点型结构体参数的接口可参照此接口"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetExposureTime(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  Get exposure time"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   Return pointer of information structure related to exposure time to user"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = "                                      float           fCurValue;      // Camera current exposure time"]
    #[doc = "                                      float           fMax;           // The maximum exposure time camera allowed"]
    #[doc = "                                      float           fMin;           // The minimum exposure time camera allowed"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Other interface of Float structure parameters can refer to this interface"]
    pub fn MV_CC_GetExposureTime(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_FLOATVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetExposureTime(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  设置曝光时间"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const float fValue          [IN]        想要设置的相机帧率"]
    #[doc = "  @return 成功,返回MV_OK,并且相机帧率将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetExposureTime(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  Set exposure time"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const float fValue          [IN]        Exposure time to set"]
    #[doc = "  @return Success, return MV_OK, and the camera exposure time value will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetExposureTime(
        handle: *mut ::std::os::raw::c_void,
        fValue: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetPixelFormat(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取像素格式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关像素格式的信息结构体指针"]
    #[doc = "          返回的pstValue结构体的意义"]
    #[doc = "          unsigned int    nCurValue;                              //  相机当前的像素格式，是枚举类型,比如说PixelType_Gvsp_Mono8, 这里获得的是其整型值,具体数值参照PixelType.h的MvGvspPixelType枚举类型"]
    #[doc = "          unsigned int    nSupportedNum;                          //  相机支持的像素格式的个数"]
    #[doc = "          unsigned int    nSupportValue[MV_MAX_XML_SYMBOLIC_NUM]; //  相机所有支持的像素格式对应的整型值列表，后面要设置像素格式时，参数必须是这个数组中的一种，否则无效"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "其他枚举类型参数接口可参照此接口，有关相应参数的枚举类型对应的整型值请查找PixelType.h 和 CameraParams.h中相应的定义"]
    #[doc = ""]
    #[doc = " @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetPixelFormat(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get Pixel Format"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Returns the information structure pointer about pixel format for the caller"]
    #[doc = "          The meaning of returns pstValue structure"]
    #[doc = "          unsigned int    nCurValue;                              //  The current pixel format of the camera, is the enumeration type, such as PixelType_Gvsp_Mono8, here is the integer value, the specific value please refer to MvGvspPixelType enumeration type in PixelType.h"]
    #[doc = "          unsigned int    nSupportedNum;                          //  Number of pixel formats supported by the camera"]
    #[doc = "          unsigned int    nSupportValue[MV_MAX_XML_SYMBOLIC_NUM]; //  The integer values list correspond to all supported pixel formats of the camera, followed by when set the pixel format, the parameter must be one of this list, otherwise invalid"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Other interface of Enumeration structure parameters can refer to this interface, look for the corresponding definition in PixelType.h and CameraParams.h for the integer values of the enum type parameter"]
    pub fn MV_CC_GetPixelFormat(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetPixelFormat(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置像素格式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的像素格式对应的整型值，调用此接口时可以直接填写枚举值，如MV_CC_SetPixelFormat(m_handle, PixelType_Gvsp_RGB8_Packed);"]
    #[doc = "  @return 成功,返回MV_OK,并且相机像素格式将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "          要设置的枚举类型必须是Get接口返回的nSupportValue[MV_MAX_XML_SYMBOLIC_NUM]中的一种，否则会失败"]
    #[doc = ""]
    #[doc = " @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetPixelFormat(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set Pixel Format"]
    #[doc = "  @param  void* handle                [IN]        Camera Handle"]
    #[doc = "          const unsigned int nValue   [IN]        The corresponding integer value for pixel format to be set, when calling this interface can be directly filled in enumeration values, such as MV_CC_SetPixelFormat(m_handle, PixelType_Gvsp_RGB8_Packed);"]
    #[doc = "  @return Success, return MV_OK, and the camera pixel format will change to the corresponding value. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Other interface of Enumeration structure parameters can refer to this interface, the enumeration type to be set must be one of the nSupportValue [MV_MAX_XML_SYMBOLIC_NUM] returned by the Get interface, otherwise it will fail"]
    pub fn MV_CC_SetPixelFormat(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取采集模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关采集模式的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_ACQUISITION_MODE 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get acquisition mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Structure pointer of acquisition mode"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_ACQUISITION_MODE in CameraParam.h"]
    pub fn MV_CC_GetAcquisitionMode(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置像素格式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的采集模式对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机采集模式将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set acquisition mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to acquisition mode"]
    #[doc = "  @return Success, return MV_OK, and the camera acquisition mode will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetAcquisitionMode(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGainMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取增益模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关增益模式的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_GAIN_MODE 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGainMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get gain mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]    Structure pointer of gain mode"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_GAIN_MODE in CameraParam.h"]
    pub fn MV_CC_GetGainMode(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGainMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置增益模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的增益模式对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机增益模式将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGainMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set gain mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to gain mode"]
    #[doc = "  @return Success, return MV_OK, and the camera gain mode will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetGainMode(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetExposureAutoMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取自动曝光模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关自动曝光模式的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_EXPOSURE_AUTO_MODE 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetExposureAutoMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get auto exposure mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Structure pointer of auto exposure mode"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_EXPOSURE_AUTO_MODE in CameraParam.h"]
    pub fn MV_CC_GetExposureAutoMode(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetExposureAutoMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置自动曝光模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的自动曝光模式对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机自动曝光模式将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetExposureAutoMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set auto exposure mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to auto exposure mode"]
    #[doc = "  @return Success, return MV_OK, and the camera auto exposure mode will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetExposureAutoMode(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取触发模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关触发模式的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_TRIGGER_MODE 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerMode(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get trigger mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Structure pointer of trigger mode"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_TRIGGER_MODE in CameraParam.h"]
    pub fn MV_CC_GetTriggerMode(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置触发模式"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的触发模式对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机触发模式将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerMode(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set trigger mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to trigger mode"]
    #[doc = "  @return Success, return MV_OK, and the camera trigger mode will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetTriggerMode(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerDelay(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  获取触发延时"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   返回给调用者有关相机触发延时的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetFrameRate"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerDelay(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  Get tigger delay"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   Structure pointer of trigger delay"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetFrameRate"]
    pub fn MV_CC_GetTriggerDelay(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_FLOATVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerDelay(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  设置触发延时"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const float fValue          [IN]        想要设置的相机触发延时"]
    #[doc = "  @return 成功,返回MV_OK,并且相机触发延时将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerDelay(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  Set tigger delay"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const float fValue          [IN]        Trigger delay to set"]
    #[doc = "  @return Success, return MV_OK, and the camera trigger delay will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetTriggerDelay(
        handle: *mut ::std::os::raw::c_void,
        fValue: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerSource(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取触发源"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关触发源的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_TRIGGER_SOURCE 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerSource(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get trigger source"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Structure pointer of trigger source"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_TRIGGER_SOURCE in CameraParam.h"]
    pub fn MV_CC_GetTriggerSource(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerSource(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置触发源"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的触发源对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机触发源将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerSource(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set trigger source"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to trigger source"]
    #[doc = "  @return Success, return MV_OK, and the camera trigger source will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetTriggerSource(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_TriggerSoftwareExecute(IN void* handle);"]
    #[doc = "  @brief  软触发一次（接口仅在已选择的触发源为软件触发时有效）"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @return 成功,返回MV_OK, 失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_TriggerSoftwareExecute(IN void* handle);"]
    #[doc = "  @brief  Execute software trigger once (this interface only valid when the trigger source is set to software)"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_TriggerSoftwareExecute(
        handle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGammaSelector(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取Gamma类型"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关Gamma类型的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_GAMMA_SELECTOR 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGammaSelector(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get Gamma mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Structure pointer of gamma mode"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_GAMMA_SELECTOR in CameraParam.h"]
    pub fn MV_CC_GetGammaSelector(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGammaSelector(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置Gamma类型"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的Gamma类型对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机Gamma类型将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGammaSelector(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set Gamma mode"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to gamma mode"]
    #[doc = "  @return Success, return MV_OK, and the camera gamma mode will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetGammaSelector(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGamma(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  获取Gamma值"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   返回给调用者有关相机Gamma值的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetFrameRate"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetGamma(IN void* handle, IN OUT MVCC_FLOATVALUE* pstValue);"]
    #[doc = "  @brief  Get Gamma value"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_FLOATVALUE* pstValue   [IN][OUT]   Structure pointer of gamma value"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetFrameRate"]
    pub fn MV_CC_GetGamma(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_FLOATVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGamma(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  设置Gamma值"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const float fValue          [IN]        想要设置的相机Gamma值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机Gamma值将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetGamma(IN void* handle, IN const float fValue);"]
    #[doc = "  @brief  Set Gamma value"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const float fValue          [IN]        Gamma value to set"]
    #[doc = "  @return Success, return MV_OK, and the camera gamma value will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetGamma(
        handle: *mut ::std::os::raw::c_void,
        fValue: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetSharpness(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取锐度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机锐度结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetSharpness(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get sharpness"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of sharpness"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetSharpness(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetSharpness(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置锐度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的锐度"]
    #[doc = "  @return 成功,返回MV_OK,并且相机锐度将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetSharpness(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set sharpness"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Sharpness to set"]
    #[doc = "  @return Success, return MV_OK, and the camera sharpness will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetSharpness(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetHue(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取灰度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机灰度结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetHue(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get Hue"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of Hue"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetHue(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetHue(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置灰度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的灰度"]
    #[doc = "  @return 成功,返回MV_OK,并且相机灰度将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetHue(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set Hue"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Hue to set"]
    #[doc = "  @return Success, return MV_OK, and the camera Hue will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetHue(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetSaturation(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取饱和度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机饱和度结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetSaturation(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get Saturation"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of Saturation"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetSaturation(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetSaturation(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置饱和度"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的饱和度"]
    #[doc = "  @return 成功,返回MV_OK,并且相机饱和度将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetSaturation(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set Saturation"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Saturation to set"]
    #[doc = "  @return Success, return MV_OK, and the camera Saturation will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetSaturation(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceWhiteAuto(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  获取自动白平衡"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   返回给调用者的有关自动白平衡的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并获得相应参数信息的结构体, 失败, 返回错误码"]
    #[doc = ""]
    #[doc = "可参照接口MV_CC_GetPixelFormat，参考 CameraParam.h 中的 MV_CAM_BALANCEWHITE_AUTO 定义"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceWhiteAuto(IN void* handle, IN OUT MVCC_ENUMVALUE* pstValue);"]
    #[doc = "  @brief  Get Auto white balance"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_ENUMVALUE* pstValue    [IN][OUT]   Structure pointer of auto white balance"]
    #[doc = "  @return Success, return MV_OK, and get the structure of the corresponding parameters. Failure, return error code"]
    #[doc = ""]
    #[doc = "Refer to MV_CC_GetPixelFormat and definition of MV_CAM_BALANCEWHITE_AUTO in CameraParam.h"]
    pub fn MV_CC_GetBalanceWhiteAuto(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceWhiteAuto(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置自动白平衡"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        要设置的自动白平衡对应的整型值"]
    #[doc = "  @return 成功,返回MV_OK,并且相机自动白平衡将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceWhiteAuto(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set Auto white balance"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Integer value to set corresponding to auto white balance"]
    #[doc = "  @return Success, return MV_OK, and the camera auto white balance will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetBalanceWhiteAuto(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioRed(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取白平衡 红"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机白平衡 红结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioRed(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get white balance red"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of white balance red"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetBalanceRatioRed(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioRed(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置白平衡 红"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的白平衡 红"]
    #[doc = "  @return 成功,返回MV_OK,并且相机白平衡 红将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioRed(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set white balance red"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        White balance red to set"]
    #[doc = "  @return Success, return MV_OK, and the camera white balance red will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetBalanceRatioRed(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioGreen(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取白平衡 绿"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机白平衡 绿结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioGreen(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get white balance green"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of white balance green"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetBalanceRatioGreen(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioGreen(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置白平衡 绿"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的白平衡 绿"]
    #[doc = "  @return 成功,返回MV_OK,并且相机白平衡 绿将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioGreen(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set white balance green"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        White balance green to set"]
    #[doc = "  @return Success, return MV_OK, and the camera white balance green will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetBalanceRatioGreen(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioBlue(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取白平衡 蓝"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机白平衡 蓝结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioBlue(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get white balance blue"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of white balance blue"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetBalanceRatioBlue(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioBlue(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置白平衡 蓝"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的白平衡 蓝"]
    #[doc = "  @return 成功,返回MV_OK,并且相机白平衡 蓝将会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioBlue(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set white balance blue"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        White balance blue to set"]
    #[doc = "  @return Success, return MV_OK, and the camera white balance blue will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetBalanceRatioBlue(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetFrameSpecInfoAbility(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取水印信息内包含的信息类型"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机水印信息内包含的信息类型结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetFrameSpecInfoAbility(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get information type included by frame stamp"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of information type included by frame stamp"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetFrameSpecInfoAbility(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetFrameSpecInfoAbility(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置水印信息内包含的信息类型"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的水印信息内包含的信息类型"]
    #[doc = "  @return 成功,返回MV_OK,并且相机水印信息内包含的信息类型会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetFrameSpecInfoAbility(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set information type included by frame stamp"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Information type included by frame stamp to set"]
    #[doc = "  @return Success, return MV_OK, and the camera information type included by frame stamp will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetFrameSpecInfoAbility(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetDeviceUserID(IN void* handle, IN OUT MVCC_STRINGVALUE* pstValue);"]
    #[doc = "  @brief  获取设备自定义名字"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          MVCC_STRINGVALUE* pstValue  [IN OUT]    返回给调用者有关相机名字结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,并且获取到相机的自定义名字，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetDeviceUserID(IN void* handle, IN OUT MVCC_STRINGVALUE* pstValue);"]
    #[doc = "  @brief  Get device user defined name"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          MVCC_STRINGVALUE* pstValue  [IN OUT]    Structure pointer of device name"]
    #[doc = "  @return Success, return MV_OK, and get the camera user defined name. Failure, return error code"]
    pub fn MV_CC_GetDeviceUserID(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_STRINGVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetDeviceUserID(IN void* handle, IN const char* chValue);"]
    #[doc = "  @brief  设置设备自定义名字"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          IN const char* chValue      [IN]        设备名字"]
    #[doc = "  @return 成功,返回MV_OK,并且设置设备自定义名字，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetDeviceUserID(IN void* handle, IN const char* chValue);"]
    #[doc = "  @brief  Set device user defined name"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          IN const char* chValue      [IN]        Device name"]
    #[doc = "  @return Success, return MV_OK, and set the camera user defined name. Failure, return error code"]
    pub fn MV_CC_SetDeviceUserID(
        handle: *mut ::std::os::raw::c_void,
        chValue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBurstFrameCount(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取一次触发的帧数"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机一次触发的帧数结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetBurstFrameCount(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get frame number trigger by once"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of frame number trigger by once"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetBurstFrameCount(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBurstFrameCount(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置一次触发的帧数"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的一次触发的帧数"]
    #[doc = "  @return 成功,返回MV_OK,并且相机一次触发的帧数会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetBurstFrameCount(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set frame number trigger by once"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Frame number trigger by once to set"]
    #[doc = "  @return Success, return MV_OK, and the camera frame number trigger by once will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetBurstFrameCount(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionLineRate(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取行频"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机行频结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionLineRate(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get line rate"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of line rate"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetAcquisitionLineRate(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionLineRate(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置行频"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的行频"]
    #[doc = "  @return 成功,返回MV_OK,并且相机行频会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionLineRate(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set line rate"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Line rate to set"]
    #[doc = "  @return Success, return MV_OK, and the camera line rate will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetAcquisitionLineRate(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetHeartBeatTimeout(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取心跳信息"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机心跳信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_GetHeartBeatTimeout(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get heartbeat information"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of heartbeat information"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_CC_GetHeartBeatTimeout(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetHeartBeatTimeout(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置心跳信息"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的心跳信息"]
    #[doc = "  @return 成功,返回MV_OK,并且相机心跳信息会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_CC_SetHeartBeatTimeout(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set heartbeat information"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Heartbeat information to set"]
    #[doc = "  @return Success, return MV_OK, and the camera heartbeat information will change to the corresponding value. Failure, return error code"]
    pub fn MV_CC_SetHeartBeatTimeout(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPSPacketSize(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取网络包大小"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机网络包大小结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPSPacketSize(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get network packet size"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of network packet size"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_GIGE_GetGevSCPSPacketSize(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPSPacketSize(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置网络包大小"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的网络包大小"]
    #[doc = "  @return 成功,返回MV_OK,并且相机网络包大小会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPSPacketSize(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set network packet size"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Packet size to set"]
    #[doc = "  @return Success, return MV_OK, and change packet size to setting value. Failure, return error code"]
    pub fn MV_GIGE_SetGevSCPSPacketSize(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPD(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  获取网络包发送间隔"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   返回给调用者有关相机网络包发送间隔结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "          可参照接口MV_CC_GetWidth"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPD(IN void* handle, IN OUT MVCC_INTVALUE* pstValue);"]
    #[doc = "  @brief  Get network packet sending delay"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  MVCC_INTVALUE* pstValue     [IN][OUT]   Structure pointer of network packet sending delay"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = ""]
    #[doc = "          Refer to MV_CC_GetWidth"]
    pub fn MV_GIGE_GetGevSCPD(
        handle: *mut ::std::os::raw::c_void,
        pstValue: *mut MVCC_INTVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPD(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  设置网络包发送间隔"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          const unsigned int nValue   [IN]        想要设置的网络包发送间隔"]
    #[doc = "  @return 成功,返回MV_OK,并且相机网络包发送间隔会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPD(IN void* handle, IN const unsigned int nValue);"]
    #[doc = "  @brief  Set network packet sending delay"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          const unsigned int nValue   [IN]        Packet delay to set"]
    #[doc = "  @return Success, return MV_OK, and change packet delay to setting value. Failure, return error code"]
    pub fn MV_GIGE_SetGevSCPD(
        handle: *mut ::std::os::raw::c_void,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCDA(IN void* handle, unsigned int* pnIP);"]
    #[doc = "  @brief  获取接收端IP地址，0xa9fe0102 表示 169.254.1.2"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  unsigned int* pnIP          [IN][OUT]   返回给调用者接收端IP地址"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCDA(IN void* handle, unsigned int* pnIP);"]
    #[doc = "  @brief  Get receiver IP address, 0xa9fe0102 indicates 169.254.1.2"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  unsigned int* pnIP          [IN][OUT]   Receiver IP address"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_GIGE_GetGevSCDA(
        handle: *mut ::std::os::raw::c_void,
        pnIP: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCDA(IN void* handle, unsigned int nIP);"]
    #[doc = "  @brief  设置接收端IP地址"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          unsigned int nIP            [IN]        想要设置的接收端IP地址"]
    #[doc = "  @return 成功,返回MV_OK,并且相机接收端IP地址会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCDA(IN void* handle, unsigned int nIP);"]
    #[doc = "  @brief  Set receiver IP address"]
    #[doc = "  @param  void* handle                [IN]        Handel"]
    #[doc = "          unsigned int nIP            [IN]        Receiver IP address to set"]
    #[doc = "  @return Success, return MV_OK, and change receiver IP address to setting value. Failure, return error code"]
    pub fn MV_GIGE_SetGevSCDA(
        handle: *mut ::std::os::raw::c_void,
        nIP: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCSP(IN void* handle, unsigned int* pnPort);"]
    #[doc = "  @brief  获取发送端的端口号"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "  @param  unsigned int* pnPort        [IN][OUT]   返回给调用者发送端的端口号"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCSP(IN void* handle, unsigned int* pnPort);"]
    #[doc = "  @brief  Get transmitter port number"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "  @param  unsigned int* pnPort        [IN][OUT]   Transmitter port number"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_GIGE_GetGevSCSP(
        handle: *mut ::std::os::raw::c_void,
        pnPort: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCSP(IN void* handle, unsigned int nPort);"]
    #[doc = "  @brief  设置发送端的端口号"]
    #[doc = "  @param  void* handle                [IN]        相机句柄"]
    #[doc = "          unsigned int nPort          [IN]        想要设置的发送端的端口号"]
    #[doc = "  @return 成功,返回MV_OK,并且相机发送端的端口号会更改为相应值，失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @fn     MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCSP(IN void* handle, unsigned int nPort);"]
    #[doc = "  @brief  Set transmitter port number"]
    #[doc = "  @param  void* handle                [IN]        Handle"]
    #[doc = "          unsigned int nPort          [IN]        Transmitter port number to set"]
    #[doc = "  @return Success, return MV_OK, and change transmitter port number to setting value. Failure, return error code"]
    pub fn MV_GIGE_SetGevSCSP(
        handle: *mut ::std::os::raw::c_void,
        nPort: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置设备波特率"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nBaudrate                   [IN]            设置的波特率值，数值参考CameraParams.h中宏定义，如#define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks （该接口已弃用，建议改用 MV_CAML_SetDeviceBaudrate接口）"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set device baudrate using one of the CL_BAUDRATE_XXXX value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nBaudrate                   [IN]            baud rate to set. Refer to the 'CameraParams.h' for parameter definitions, for example, #define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks (This interface is abandoned, it is recommended to use the MV_CAML_SetDeviceBaudrate)"]
    pub fn MV_CAML_SetDeviceBauderate(
        handle: *mut ::std::os::raw::c_void,
        nBaudrate: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取设备波特率"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnCurrentBaudrate           [OUT]           波特率信息指针，数值参考CameraParams.h中宏定义，如#define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks （该接口已弃用，建议改用 MV_CAML_GetDeviceBaudrate接口）"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Returns the current device baudrate, using one of the CL_BAUDRATE_XXXX value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnCurrentBaudrate           [OUT]           Return pointer of baud rate to user. Refer to the 'CameraParams.h' for parameter definitions, for example, #define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks (This interface is abandoned, it is recommended to use the MV_CAML_GetDeviceBaudrate)"]
    pub fn MV_CAML_GetDeviceBauderate(
        handle: *mut ::std::os::raw::c_void,
        pnCurrentBaudrate: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取设备与主机间连接支持的波特率"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnBaudrateAblity            [OUT]           支持的波特率信息的指针。所支持波特率的或运算结果，单个数值参考CameraParams.h中宏定义，如MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks （该接口已弃用，建议改用 MV_CAML_GetSupportBaudrates接口）"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Returns supported baudrates of the combined device and host interface"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnBaudrateAblity            [OUT]           Return pointer of the supported baudrates to user. 'OR' operation results of the supported baudrates. Refer to the 'CameraParams.h' for single value definitions, for example, MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks (This interface is abandoned, it is recommended to use the MV_CAML_GetSupportBaudrates)"]
    pub fn MV_CAML_GetSupportBauderates(
        handle: *mut ::std::os::raw::c_void,
        pnBaudrateAblity: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取SDK版本号"]
    #[doc = "  @return 返回4字节版本号"]
    #[doc = "|主    |次    |修正  |  测试|"]
    #[doc = "8bits  8bits  8bits  8bits"]
    #[doc = "  @remarks 比如返回值为0x01000001，即SDK版本号为V1.0.0.1。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get SDK Version"]
    #[doc = "  @return Always return 4 Bytes of version number"]
    #[doc = "|Main    |Sub    |Rev  |  Test|"]
    #[doc = "8bits  8bits  8bits  8bits"]
    #[doc = "  @remarks For example, if the return value is 0x01000001, the SDK version is V1.0.0.1."]
    pub fn MV_CC_GetSDKVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取支持的传输层"]
    #[doc = "  @return 支持的传输层编号"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get supported Transport Layer"]
    #[doc = "  @return Supported Transport Layer number"]
    pub fn MV_CC_EnumerateTls() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  枚举设备"]
    #[doc = "  @param  nTLayerType                 [IN]            枚举传输层"]
    #[doc = "  @param  pstDevList                  [OUT]           设备列表"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设备列表的内存是在SDK内部分配的，多线程调用该接口时会进行设备列表内存的释放和申请，\\n"]
    #[doc = "建议尽量避免多线程枚举操作。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Enumerate Device"]
    #[doc = "  @param  nTLayerType                 [IN]            Enumerate TLs"]
    #[doc = "  @param  pstDevList                  [OUT]           Device List"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks The memory of the device list is allocated within the SDK. When the interface is invoked by multiple threads, the memory of the device list will be released and applied.\\n"]
    #[doc = "It is recommended to avoid multithreaded enumeration operations as much as possible."]
    pub fn MV_CC_EnumDevices(
        nTLayerType: ::std::os::raw::c_uint,
        pstDevList: *mut MV_CC_DEVICE_INFO_LIST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  根据厂商名字枚举设备"]
    #[doc = "  @param  nTLayerType                 [IN]            枚举传输层"]
    #[doc = "  @param  pstDevList                  [OUT]           设备列表"]
    #[doc = "  @param  strManufacturerName           [IN]            厂商名字"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设备列表的内存是在SDK内部分配的，多线程调用该接口时会进行设备列表内存的释放和申请，\\n"]
    #[doc = "建议尽量避免多线程枚举操作。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Enumerate device according to manufacture name"]
    #[doc = "  @param  nTLayerType                 [IN]            Transmission layer of enumeration"]
    #[doc = "  @param  pstDevList                  [OUT]           Device list"]
    #[doc = "  @param  strManufacturerName           [IN]            Manufacture Name"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks The memory of the device list is allocated within the SDK. When the interface is invoked by multiple threads, the memory of the device list will be released and applied.\\n"]
    #[doc = "It is recommended to avoid multithreaded enumeration operations as much as possible."]
    pub fn MV_CC_EnumDevicesEx(
        nTLayerType: ::std::os::raw::c_uint,
        pstDevList: *mut MV_CC_DEVICE_INFO_LIST,
        strManufacturerName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设备是否可达"]
    #[doc = "  @param  pstDevInfo                  [IN]            设备信息结构体"]
    #[doc = "  @param  nAccessMode                 [IN]            访问权限"]
    #[doc = "  @return 可达，返回true；不可达，返回false"]
    #[doc = "  @remarks 读取设备CCP寄存器的值，判断当前状态是否具有某种访问权限。 \\n"]
    #[doc = "如果设备不支持MV_ACCESS_ExclusiveWithSwitch、MV_ACCESS_ControlWithSwitch、MV_ACCESS_ControlSwitchEnableWithKey这三种模式，接口返回false。目前设备不支持这3种抢占模式，国际上主流的厂商的设备也都暂不支持这3种模式。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Is the device accessible"]
    #[doc = "  @param  pstDevInfo                  [IN]            Device Information Structure"]
    #[doc = "  @param  nAccessMode                 [IN]            Access Right"]
    #[doc = "  @return Access, return true. Not access, return false"]
    #[doc = "  @remarks Read device CCP register value and determine current access permission.\\n"]
    #[doc = "Return false if the device does not support the modes MV_ACCESS_ExclusiveWithSwitch, MV_ACCESS_ControlWithSwitch, MV_ACCESS_ControlSwitchEnableWithKey. Currently the device does not support the 3 preemption modes, neither do the devices from other mainstream manufacturers. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_IsDeviceAccessible(
        pstDevInfo: *mut MV_CC_DEVICE_INFO,
        nAccessMode: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置SDK日志路径"]
    #[doc = "  @param  strSDKLogPath             [IN]           SDK日志路径"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设置路径之后，可以指定路径存放日志。\\n"]
    #[doc = "v2.4.1版本新增日志服务，开启服务之后该接口无效，默认日志服务为开启状态。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set SDK log path"]
    #[doc = "  @param  strSDKLogPath             [IN]           SDK log path"]
    #[doc = "  @return Access, return true. Not access, return false"]
    #[doc = "  @remarks For version V2.4.1, added log service, this API is invalid when the service is enabled.And The logging service is enabled by default\\n"]
    #[doc = "This API is used to set the log file storing path."]
    pub fn MV_CC_SetSDKLogPath(
        strSDKLogPath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  创建设备句柄"]
    #[doc = "  @param  handle                      [OUT]           设备句柄"]
    #[doc = "  @param  pstDevInfo                  [IN]            设备信息结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 根据输入的设备信息，创建库内部必须的资源和初始化内部模块。通过该接口创建句柄，调用SDK接口，会默认生成SDK日志文件，如果不需要生成日志文件，可以通过MV_CC_CreateHandleWithoutLog创建句柄。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Create Device Handle"]
    #[doc = "  @param  handle                      [OUT]           Device handle"]
    #[doc = "  @param  pstDevInfo                  [IN]            Device Information Structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Create required resources within library and initialize internal module according to input device information. Create handle and call SDK interface through this interface, and SDK log file will be created by default. Creating handle through MV_CC_CreateHandleWithoutLog will not generate log files."]
    pub fn MV_CC_CreateHandle(
        handle: *mut *mut ::std::os::raw::c_void,
        pstDevInfo: *const MV_CC_DEVICE_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  创建设备句柄，不生成日志"]
    #[doc = "  @param  handle                      [OUT]           设备句柄"]
    #[doc = "  @param  pstDevInfo                  [IN]            设备信息结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 根据输入的设备信息，创建库内部必须的资源和初始化内部模块。通过该接口创建句柄，调用SDK接口，不会默认生成SDK日志文件，如果需要生成日志文件可以通过MV_CC_CreateHandle创建句柄，日志文件自动生成。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Create Device Handle without log"]
    #[doc = "  @param  handle                      [OUT]           Device handle"]
    #[doc = "  @param  pstDevInfo                  [IN]            Device Information Structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Create required resources within library and initialize internal module according to input device information. Create handle and call SDK interface through this interface, and SDK log file will not be created. To create logs, create handle through MV_CC_CreateHandle, and log files will be automatically generated."]
    pub fn MV_CC_CreateHandleWithoutLog(
        handle: *mut *mut ::std::os::raw::c_void,
        pstDevInfo: *const MV_CC_DEVICE_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  销毁设备句柄"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Destroy Device Handle"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_DestroyHandle(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MV_CC_OpenDevice(
        handle: *mut ::std::os::raw::c_void,
        nAccessMode: ::std::os::raw::c_uint,
        nSwitchoverKey: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  关闭设备"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过MV_CC_OpenDevice连接设备后，可以通过该接口断开设备连接，释放资源"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Close Device"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After connecting to device through MV_CC_OpenDevice, use this interface to disconnect and release resources."]
    pub fn MV_CC_CloseDevice(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  判断设备是否处于连接状态"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 设备处于连接状态，返回true；没连接或失去连接，返回false"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Is The Device Connected"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Connected, return true. Not Connected or DIsconnected, return false"]
    pub fn MV_CC_IsDeviceConnected(handle: *mut ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  注册图像数据回调"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  cbOutput                    [IN]            回调函数指针"]
    #[doc = "  @param  pUser                       [IN]            用户自定义变量"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过该接口可以设置图像数据回调函数，在MV_CC_CreateHandle之后即可调用。 \\n"]
    #[doc = "图像数据采集有两种方式，两种方式不能复用：\\n"]
    #[doc = "方式一：调用MV_CC_RegisterImageCallBackEx设置图像数据回调函数，然后调用MV_CC_StartGrabbing开始采集，采集的图像数据在设置的回调函数中返回。\\n"]
    #[doc = "方式二：调用MV_CC_StartGrabbing开始采集，然后在应用层循环调用MV_CC_GetOneFrameTimeout获取指定像素格式的帧数据，获取帧数据时上层应用程序需要根据帧率控制好调用该接口的频率。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Register the image callback function"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  cbOutput                    [IN]            Callback function pointer"]
    #[doc = "  @param  pUser                       [IN]            User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After MV_CC_CreateHandle, call this interface to set image data callback function.\\n"]
    #[doc = "There are two available image data acquisition modes, and cannot be used together: \\n"]
    #[doc = "Mode 1: Call MV_CC_RegisterImageCallBack to set image data callback function, and then callMV_CC_StartGrabbing to start acquiring. The acquired image data will return in the set callback function.\\n"]
    #[doc = "Mode 2: Call MV_CC_StartGrabbing to start acquiring, and then call MV_CC_GetOneFrameTimeout repeatedly in application layer to get frame data of specified pixel format. When getting frame data, the frequency of calling this interface should be controlled by upper layer application according to frame rate. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_RegisterImageCallBackEx(
        handle: *mut ::std::os::raw::c_void,
        cbOutput: ::std::option::Option<
            unsafe extern "C" fn(
                pData: *mut ::std::os::raw::c_uchar,
                pFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  注册图像数据回调，RGB"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  cbOutput                    [IN]            回调函数指针"]
    #[doc = "  @param  pUser                       [IN]            用户自定义变量"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过该接口可以设置图像数据回调函数，在MV_CC_CreateHandle之后即可调用。 \\n"]
    #[doc = "图像数据采集有两种方式，两种方式不能复用：\\n"]
    #[doc = "方式一：调用MV_CC_RegisterImageCallBackForRGB设置RGB24格式图像数据回调函数，然后调用MV_CC_StartGrabbing开始采集，采集的图像数据在设置的回调函数中返回。\\n"]
    #[doc = "方式二：调用MV_CC_StartGrabbing开始采集，然后在应用层循环调用MV_CC_GetImageForRGB获取RGB24格式的帧数据，获取帧数据时上层应用程序需要根据帧率控制好调用该接口的频率。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  register image data callback, RGB"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  cbOutput                    [IN]            Callback function pointer"]
    #[doc = "  @param  pUser                       [IN]            User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Before calling this API to set image data callback function, you should call this API MV_CC_CreateHandle. \\n"]
    #[doc = "There are two image acquisition modes, the two modes cannot be reused: \\n"]
    #[doc = "Mode 1: Call MV_CC_RegisterImageCallBackForRGB to set RGB24 format image data callback function, and then call MV_CC_StartGrabbing to start acquisition, the collected image data will be returned in the configured callback function.\\n"]
    #[doc = "Mode 2: Call MV_CC_StartGrabbing to start acquisition, and the call MV_CC_GetImageForRGB repeatedly in application layer to get frame data with RGB24 format. When getting frame data, the upper application program should control the frequency of calling this API according to frame rate. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_RegisterImageCallBackForRGB(
        handle: *mut ::std::os::raw::c_void,
        cbOutput: ::std::option::Option<
            unsafe extern "C" fn(
                pData: *mut ::std::os::raw::c_uchar,
                pFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  注册图像数据回调，BGR"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  cbOutput                    [IN]            回调函数指针"]
    #[doc = "  @param  pUser                       [IN]            用户自定义变量"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过该接口可以设置图像数据回调函数，在MV_CC_CreateHandle之后即可调用。\\n"]
    #[doc = "图像数据采集有两种方式，两种方式不能复用：\\n"]
    #[doc = "方式一：调用MV_CC_RegisterImageCallBackForBGR设置BGR24图像数据回调函数，然后调用MV_CC_StartGrabbing开始采集，采集的图像数据在设置的回调函数中返回。\\n"]
    #[doc = "方式二：调用MV_CC_StartGrabbing开始采集，然后在应用层循环调用MV_CC_GetImageForBGR获取BGR24格式的帧数据，获取帧数据时上层应用程序需要根据帧率控制好调用该接口的频率。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  register image data callback, BGR"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  cbOutput                    [IN]            Callback function pointer"]
    #[doc = "  @param  pUser                       [IN]            User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Before calling this API to set image data callback function, you should call this API MV_CC_CreateHandle. \\n"]
    #[doc = "There are two image acquisition modes, the two modes cannot be reused: \\n"]
    #[doc = "Mode 1: Call MV_CC_RegisterImageCallBackForBGR to set RGB24 format image data callback function, and then call MV_CC_StartGrabbing to start acquisition, the collected image data will be returned in the configured callback function.\\n"]
    #[doc = "Mode 2: Call MV_CC_StartGrabbing to start acquisition, and the call MV_CC_GetImageForBGR repeatedly in application layer to get frame data with BGR24 format. When getting frame data, the upper application program should control the frequency of calling this API according to frame rate.\\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_RegisterImageCallBackForBGR(
        handle: *mut ::std::os::raw::c_void,
        cbOutput: ::std::option::Option<
            unsafe extern "C" fn(
                pData: *mut ::std::os::raw::c_uchar,
                pFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  开始取流"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Start Grabbing"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is not supported by CameraLink device."]
    pub fn MV_CC_StartGrabbing(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  停止取流"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Stop Grabbing"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is not supported by CameraLink device."]
    pub fn MV_CC_StopGrabbing(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取一帧RGB数据，此函数为查询式获取，每次调用查询内部"]
    #[doc = "缓存有无数据，有数据则获取数据，无数据返回错误码"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pData                       [OUT]           图像数据接收指针"]
    #[doc = "  @param  nDataSize                   [IN]            接收缓存大小"]
    #[doc = "  @param  pstFrameInfo                [OUT]           图像信息结构体"]
    #[doc = "  @param  nMsec                       [IN]            等待超时时间"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 每次调用该接口，将查询内部缓存是否有数据，如果有数据则转换成RGB24格式返回，如果没有数据则返回错误码。因为图像转换成RGB24格式有耗时，所以当数据帧率过高时该接口可能会导致丢帧。\\n"]
    #[doc = "调用该接口获取图像数据帧之前需要先调用MV_CC_StartGrabbing启动图像采集。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get one frame of RGB data, this function is using query to get data"]
    #[doc = "query whether the internal cache has data, get data if there has, return error code if no data"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pData                       [OUT]           Image data receiving buffer"]
    #[doc = "  @param  nDataSize                   [IN]            Buffer size"]
    #[doc = "  @param  pstFrameInfo                [OUT]           Image information structure"]
    #[doc = "  @param  nMsec                       [IN]            Waiting timeout"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Each time the API is called, the internal cache is checked for data. If there is data, it will be transformed as RGB24 format for return, if there is no data, return error code. As time-consuming exists when transform the image to RGB24 format, this API may cause frame loss when the data frame rate is too high. \\n"]
    #[doc = "Before calling this API to get image data frame, call MV_CC_StartGrabbing to start image acquisition. This API can get frame data actively, the upper layer program should control the frequency of calling this API according to the frame rate. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_GetImageForRGB(
        handle: *mut ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_uchar,
        nDataSize: ::std::os::raw::c_uint,
        pstFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
        nMsec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取一帧BGR数据，此函数为查询式获取，每次调用查询内部"]
    #[doc = "缓存有无数据，有数据则获取数据，无数据返回错误码"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pData                       [OUT]           图像数据接收指针"]
    #[doc = "  @param  nDataSize                   [IN]            接收缓存大小"]
    #[doc = "  @param  pstFrameInfo                [OUT]           图像信息结构体"]
    #[doc = "  @param  nMsec                       [IN]            等待超时时间"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 每次调用该接口，将查询内部缓存是否有数据，如果有数据则转换成BGR24格式返回，如果没有数据则返回错误码。因为图像转换成BGR24格式有耗时，所以当数据帧率过高时该接口可能会导致丢帧。 \\n"]
    #[doc = "调用该接口获取图像数据帧之前需要先调用MV_CC_StartGrabbing启动图像采集。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率。\\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get one frame of BGR data, this function is using query to get data"]
    #[doc = "query whether the internal cache has data, get data if there has, return error code if no data"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pData                       [OUT]           Image data receiving buffer"]
    #[doc = "  @param  nDataSize                   [IN]            Buffer size"]
    #[doc = "  @param  pstFrameInfo                [OUT]           Image information structure"]
    #[doc = "  @param  nMsec                       [IN]            Waiting timeout"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Before calling this API to set image data callback function, you should call this API MV_CC_CreateHandle. \\n"]
    #[doc = "There are two image acquisition modes, the two modes cannot be reused: \\n"]
    #[doc = "Mode 1: Call MV_CC_RegisterImageCallBackForBGR to set RGB24 format image data callback function, and then call MV_CC_StartGrabbing to start acquisition, the collected image data will be returned in the configured callback function.\\n"]
    #[doc = "Mode 2: Call MV_CC_StartGrabbing to start acquisition, and the call MV_CC_GetImageForBGR repeatedly in application layer to get frame data with BGR24 format. When getting frame data, the upper application program should control the frequency of calling this API according to frame rate. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_GetImageForBGR(
        handle: *mut ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_uchar,
        nDataSize: ::std::os::raw::c_uint,
        pstFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
        nMsec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  使用内部缓存获取一帧图片（与MV_CC_Display不能同时使用）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstFrame                    [OUT]           图像数据和图像信息"]
    #[doc = "  @param  nMsec                       [IN]            等待超时时间，输入INFINITE时表示无限等待，直到收到一帧数据或者停止取流"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 调用该接口获取图像数据帧之前需要先调用MV_CC_StartGrabbing启动图像采集。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率。该接口支持设置超时时间，SDK内部等待直到有数据时返回，可以增加取流平稳性，适合用于对平稳性要求较高的场合。 \\n"]
    #[doc = "该接口与MV_CC_FreeImageBuffer配套使用，当处理完取到的数据后，需要用MV_CC_FreeImageBuffer接口将pFrame内的数据指针权限进行释放。 \\n"]
    #[doc = "该接口与MV_CC_GetOneFrameTimeout相比，有着更高的效率。且其取流缓存的分配是由sdk内部自动分配的，而MV_CC_GetOneFrameTimeout接口是需要客户自行分配。\\n"]
    #[doc = "该接口在调用MV_CC_Display后无法取流。 \\n"]
    #[doc = "该接口对于U3V、GIGE设备均可支持。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get a frame of an image using an internal cache"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstFrame                    [OUT]           Image data and image information"]
    #[doc = "  @param  nMsec                       [IN]            Waiting timeout"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Before calling this API to get image data frame, you should call MV_CC_StartGrabbing to start image acquisition. This API can get frame data actively, the upper layer program should control the frequency of calling this API according to the frame rate. This API support setting timeout, and SDK will wait to return until data appears. This function will increase the streaming stability, which can be used in the situation with high stability requirement. \\n"]
    #[doc = "This API and MV_CC_FreeImageBuffer should be called in pairs, after processing the acquired data, you should call MV_CC_FreeImageBuffer to release the data pointer permission of pFrame. \\n"]
    #[doc = "This interface is more efficient than MV_CC_GetOneFrameTimeout. The allocation of the stream cache is automatically allocated within the SDK.The MV_CC_GetOneFrameTimeout interface needs to be allocated by customers themselves. \\n"]
    #[doc = "This API cannot be called to stream after calling MV_CC_Display. \\n"]
    #[doc = "This API is not supported by CameraLink device. \\n"]
    #[doc = "This API is supported by both USB3 vision camera and GigE camera. \\n"]
    pub fn MV_CC_GetImageBuffer(
        handle: *mut ::std::os::raw::c_void,
        pstFrame: *mut MV_FRAME_OUT,
        nMsec: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  释放图像缓存(此接口用于释放不再使用的图像缓存，与MV_CC_GetImageBuffer配套使用)"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstFrame                    [IN]            图像数据和图像数据"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口与MV_CC_GetImageBuffer配套使用，使用MV_CC_GetImageBuffer接口取到的图像数据pFrame，需要用MV_CC_FreeImageBuffer接口进行权限释放。 \\n"]
    #[doc = "该接口对于取流效率高于GetOneFrameTimeout接口，且GetImageBuffer在不进行Free的情况下，最大支持输出的节点数与SetImageNode接口所设置的节点数相等，默认节点数是1。\\n"]
    #[doc = "该接口对于U3V、GIGE设备均可支持。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Free image buffer(this interface can free image buffer, used with MV_CC_GetImageBuffer)"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstFrame                    [IN]            Image data and image information"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API and MV_CC_GetImageBuffer should be called in pairs, before calling MV_CC_GetImageBuffer to get image data pFrame, you should call MV_CC_FreeImageBuffer to release the permission. \\n"]
    #[doc = "Compared with API MV_CC_GetOneFrameTimeout, this API has higher efficiency of image acquisition. The max. number of nodes can be outputted is same as the \"nNum\" of API MV_CC_SetImageNodeNum, default value is 1. \\n"]
    #[doc = "This API is not supported by CameraLink device. \\n"]
    #[doc = "This API is supported by both USB3 vision camera and GigE camera."]
    pub fn MV_CC_FreeImageBuffer(
        handle: *mut ::std::os::raw::c_void,
        pstFrame: *mut MV_FRAME_OUT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  采用超时机制获取一帧图片，SDK内部等待直到有数据时返回"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pData                       [OUT]           图像数据接收指针"]
    #[doc = "  @param  nDataSize                   [IN]            接收缓存大小"]
    #[doc = "  @param  pstFrameInfo                [OUT]           图像信息结构体"]
    #[doc = "  @param  nMsec                       [IN]            等待超时时间"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 调用该接口获取图像数据帧之前需要先调用MV_CC_StartGrabbing启动图像采集。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率。该接口支持设置超时时间，SDK内部等待直到有数据时返回，可以增加取流平稳性，适合用于对平稳性要求较高的场合。\\n"]
    #[doc = "该接口对于U3V、GIGE设备均可支持。\\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Timeout mechanism is used to get image, and the SDK waits inside until the data is returned"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pData                       [OUT]           Image data receiving buffer"]
    #[doc = "  @param  nDataSize                   [IN]            Buffer size"]
    #[doc = "  @param  pstFrameInfo                [OUT]           Image information structure"]
    #[doc = "  @param  nMsec                       [IN]            Waiting timeout"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Before calling this API to get image data frame, call MV_CC_StartGrabbing to start image acquisition. This API can get frame data actively, the upper layer program should control the frequency of calling this API according to the frame rate. This API supports setting timeout, SDK will wait to return until data appears. This function will increase the streaming stability, which can be used in the situation with high stability requirement. \\n"]
    #[doc = "Both the USB3Vision and GIGE camera can support this API. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_GetOneFrameTimeout(
        handle: *mut ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_uchar,
        nDataSize: ::std::os::raw::c_uint,
        pstFrameInfo: *mut MV_FRAME_OUT_INFO_EX,
        nMsec: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  清除取流数据缓存"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口允许用户在不停止取流的时候，就能清除缓存中不需要的图像。\\n"]
    #[doc = "该接口在连续模式切触发模式后，可以清除历史数据。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  if Image buffers has retrieved the data，Clear them"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface allows user to clear the unnecessary images from the buffer memory without stopping acquisition. \\n"]
    #[doc = "This interface allows user to clear previous data after switching from continuous mode to trigger mode."]
    pub fn MV_CC_ClearImageBuffer(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  显示一帧图像"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstDisplayInfo              [IN]            图像信息"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口对于U3V、GIGE设备均可支持。\\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Display one frame image"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstDisplayInfo              [IN]            Frame Info"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is valid for USB3Vision camera and GIGE camera. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_DisplayOneFrame(
        handle: *mut ::std::os::raw::c_void,
        pstDisplayInfo: *mut MV_DISPLAY_FRAME_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置SDK内部图像缓存节点个数，大于等于1，在抓图前调用"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nNum                        [IN]            缓存节点个数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 调用该接口可以设置SDK内部图像缓存节点个数，在调用MV_CC_StartGrabbing开始抓图前调用。\\n"]
    #[doc = "在SDK中默认是1个节点。\\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set the number of the internal image cache nodes in SDK, Greater than or equal to 1, to be called before the capture"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nNum                        [IN]            Image Node Number"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this interface to set the number of SDK internal image buffer nodes. The interface should be called before calling MV_CC_StartGrabbing for capturing. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_SetImageNodeNum(
        handle: *mut ::std::os::raw::c_void,
        nNum: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置取流策略"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  enGrabStrategy              [IN]            策略枚举值"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口定义了四种取流策略，用户可以根据实际需求进行选择。具体描述如下："]
    #[doc = "-OneByOne:从旧到新一帧一帧的从输出缓存列表中获取图像，打开设备后默认为该策略"]
    #[doc = "-LatestImagesOnly:仅从输出缓存列表中获取最新的一帧图像，同时清空输出缓存列表"]
    #[doc = "-LatestImages:从输出缓存列表中获取最新的OutputQueueSize帧图像，其中OutputQueueSize范围为1-ImageNodeNum，可用MV_CC_SetOutputQueueSize接口设置，ImageNodeNum默认为1，可用MV_CC_SetImageNodeNum接口设置 OutputQueueSize设置成1等同于LatestImagesOnly策略，OutputQueueSize设置成ImageNodeNum等同于OneByOne策略"]
    #[doc = "-UpcomingImage:在调用取流接口时忽略输出缓存列表中所有图像，并等待设备即将生成的一帧图像。该策略只支持GigE设备，不支持U3V设备"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Grab Strategy"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  enGrabStrategy              [IN]            The value of Grab Strategy"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is set by four image acquisition approaches, the user may choose one as needed. Specific details are as followed:"]
    #[doc = "-OneByOne:Obtain image from output cache list frame by frame in order, this function is default strategy when device is on."]
    #[doc = "-LatestImagesOnly:Obtain the latest image from output cache list only, meanwhile clear output cache list."]
    #[doc = "-LatestImages:Obtain the latest OutputQueueSize image from output cache list, the range of OutputQueueSize is 1-ImageNodeNum, the user may set the value of MV_CC_SetOutputQueueSizeinterface,the default value of ImageNodeNum is 1,If the user usesMV_CC_SetImageNodeNuminterface to set up OutputQueueSize,when the value of OutputQueueSize is set to be 1, the function will be same as LatestImagesOnly; if the value of OutputQueueSize is set to be ImageNodeNum, the function will be same as OneByOne."]
    #[doc = "-UpcomingImage:Ignore all images in output cache list when calling image acuiqisiotn interface, wait the next upcoming image generated. Support for GigE camera only, not support for U3V camera."]
    pub fn MV_CC_SetGrabStrategy(
        handle: *mut ::std::os::raw::c_void,
        enGrabStrategy: MV_GRAB_STRATEGY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置输出缓存个数（只有在MV_GrabStrategy_LatestImages策略下才有效，范围：1-ImageNodeNum）"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nOutputQueueSize            [IN]            输出缓存个数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口需与LatestImages取流策略配套调用，用于设置LatestImages策略下最多允许缓存图像的个数。可以在取流过程中动态调节输出缓存个数"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set The Size of Output Queue(Only work under the strategy of MV_GrabStrategy_LatestImages，rang：1-ImageNodeNum)"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nOutputQueueSize            [IN]            The Size of Output Queue"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface must be used with LatestImages Grab strategy, it is used for setting the maximum allowance queue size of the image under the LatestImages strategy. The user may change the output queue size while grabbing images."]
    pub fn MV_CC_SetOutputQueueSize(
        handle: *mut ::std::os::raw::c_void,
        nOutputQueueSize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取设备信息，取流之前调用"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstDevInfo                  [IN][OUT]       返回给调用者有关设备信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 支持用户在打开设备后获取设备信息。\\n"]
    #[doc = "若该设备是GigE设备，则调用该接口存在阻塞风险，因此不建议在取流过程中调用该接口。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get device information"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstDevInfo                  [IN][OUT]       Structure pointer of device information"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks The API support users to access device information after opening the device. \\n"]
    #[doc = "If the device is a GigE camera, there is a blocking risk in calling the interface, so it is not recommended to call the interface during the fetching process."]
    pub fn MV_CC_GetDeviceInfo(
        handle: *mut ::std::os::raw::c_void,
        pstDevInfo: *mut MV_CC_DEVICE_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取各种类型的信息"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstInfo                     [IN][OUT]       返回给调用者有关设备各种类型的信息结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 接口里面输入需要获取的信息类型（指定MV_ALL_MATCH_INFO结构体中的nType类型），获取对应的信息（在MV_ALL_MATCH_INFO结构体中pInfo里返回）。 \\n"]
    #[doc = "该接口的调用前置条件取决于所获取的信息类型，获取GigE设备的MV_MATCH_TYPE_NET_DETECT信息需在开启抓图之后调用，获取U3V设备的MV_MATCH_TYPE_USB_DETECT信息需在打开设备之后调用。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get various type of information"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstInfo                     [IN][OUT]       Structure pointer of various type of information"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Input required information type (specify nType in structure MV_ALL_MATCH_INFO) in the interface and get corresponding information (return in pInfo of structure MV_ALL_MATCH_INFO). \\n"]
    #[doc = "The calling precondition of this interface is determined by obtained information type. Call after enabling capture to get MV_MATCH_TYPE_NET_DETECT information of GigE device, and call after starting device to get MV_MATCH_TYPE_USB_DETECT information of USB3Vision device. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_GetAllMatchInfo(
        handle: *mut ::std::os::raw::c_void,
        pstInfo: *mut MV_ALL_MATCH_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取Integer属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值，如获取宽度信息则为\"Width\""]
    #[doc = "  @param  pstIntValue                 [IN][OUT]       返回给调用者有关设备属性结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以获取int类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IInteger”的节点值都可以通过该接口获取，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Integer value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value, for example, using \"Width\" to get width"]
    #[doc = "  @param  pstIntValue                 [IN][OUT]       Structure pointer of camera features"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks You can call this API to get the value of camera node with integer type after connecting the device. For strKey value, refer to MvCameraNode. All the node values of \"IInteger\" in the list can be obtained via this API. strKey corresponds to the Name column."]
    pub fn MV_CC_GetIntValueEx(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        pstIntValue: *mut MVCC_INTVALUE_EX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Integer型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值，如获取宽度信息则为\"Width\""]
    #[doc = "  @param  nValue                      [IN]            想要设置的设备的属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置int类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IInteger”的节点值都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Integer value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value, for example, using \"Width\" to set width"]
    #[doc = "  @param  nValue                      [IN]            Feature value to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks You can call this API to get the value of camera node with integer type after connecting the device. For strKey value, refer to MvCameraNode. All the node values of \"IInteger\" in the list can be obtained via this API. strKey corresponds to the Name column."]
    pub fn MV_CC_SetIntValueEx(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        nValue: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取Enum属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值，如获取像素格式信息则为\"PixelFormat\""]
    #[doc = "  @param  pstEnumValue                [IN][OUT]       返回给调用者有关设备属性结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以获取Enum类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IEnumeration”的节点值都可以通过该接口获取，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Enum value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value, for example, using \"PixelFormat\" to get pixel format"]
    #[doc = "  @param  pstEnumValue                [IN][OUT]       Structure pointer of camera features"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to get specified Enum nodes. For value of strKey, see MvCameraNode, The node values of IEnumeration can be obtained through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_GetEnumValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        pstEnumValue: *mut MVCC_ENUMVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Enum型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值，如获取像素格式信息则为\"PixelFormat\""]
    #[doc = "  @param  nValue                      [IN]            想要设置的设备的属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置Enum类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IEnumeration”的节点值都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Enum value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value, for example, using \"PixelFormat\" to set pixel format"]
    #[doc = "  @param  nValue                      [IN]            Feature value to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to get specified Enum nodes. For value of strKey, see MvCameraNode, The node values of IEnumeration can be obtained through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_SetEnumValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        nValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Enum型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值，如获取像素格式信息则为\"PixelFormat\""]
    #[doc = "  @param  strValue                    [IN]            想要设置的设备的属性字符串"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置Enum类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IEnumeration”的节点值都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Enum value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value, for example, using \"PixelFormat\" to set pixel format"]
    #[doc = "  @param  strValue                    [IN]            Feature String to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this API after connecting the device. All the values of nodes with IEnumeration type can be set via this API."]
    pub fn MV_CC_SetEnumValueByString(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        strValue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取Float属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @param  pstFloatValue               [IN][OUT]       返回给调用者有关设备属性结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以获取float类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IFloat”的节点值都可以通过该接口获取，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Float value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @param  pstFloatValue               [IN][OUT]       Structure pointer of camera features"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to get specified float node. For detailed strKey value see: MvCameraNode. The node values of IFloat can be obtained through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_GetFloatValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        pstFloatValue: *mut MVCC_FLOATVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置float型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @param  fValue                      [IN]            想要设置的设备的属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置float类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IFloat”的节点值都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set float value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @param  fValue                      [IN]            Feature value to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to set specified float node. For detailed strKey value see: MvCameraNode. The node values of IFloat can be set through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_SetFloatValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        fValue: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取Boolean属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @param  pbValue                     [IN][OUT]       返回给调用者有关设备属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以获取bool类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IBoolean”的节点值都可以通过该接口获取，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Boolean value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @param  pbValue                     [IN][OUT]       Structure pointer of camera features"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to get specified bool nodes. For value of strKey, see MvCameraNode. The node values of IBoolean can be obtained through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_GetBoolValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        pbValue: *mut bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Boolean型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @param  bValue                      [IN]            想要设置的设备的属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置bool类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IBoolean”的节点值都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Boolean value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @param  bValue                      [IN]            Feature value to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to set specified bool nodes. For value of strKey, see MvCameraNode. The node values of IBoolean can be set through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_SetBoolValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        bValue: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取String属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @param  pstStringValue              [IN][OUT]       返回给调用者有关设备属性结构体指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以获取string类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IString”的节点值都可以通过该接口获取，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get String value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @param  pstStringValue              [IN][OUT]       Structure pointer of camera features"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to get specified string nodes. For value of strKey, see MvCameraNode. The node values of IString can be obtained through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_GetStringValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        pstStringValue: *mut MVCC_STRINGVALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置String型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @param  strValue                    [IN]            想要设置的设备的属性值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置string类型的指定节点的值。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“IString”的节点值都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set String value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @param  strValue                    [IN]            Feature value to set"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to set specified string nodes. For value of strKey, see MvCameraNode. The node values of IString can be set through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_SetStringValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
        strValue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Command型属性值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strKey                      [IN]            属性键值"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置指定的Command类型节点。strKey取值可以参考XML节点参数类型列表，表格里面数据类型为“ICommand”的节点都可以通过该接口设置，strKey参数取值对应列表里面的“名称”一列。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Send Command"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strKey                      [IN]            Key value"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to set specified Command nodes. For value of strKey, see MvCameraNode. The node values of ICommand can be set through this interface, strKey value corresponds to the Name column."]
    pub fn MV_CC_SetCommandValue(
        handle: *mut ::std::os::raw::c_void,
        strKey: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  清除GenICam节点缓存"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Invalidate GenICam Nodes"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_InvalidateNodes(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设备本地升级"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strFilePathName             [IN]            文件名"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 通过该接口可以将升级固件文件发送给设备进行升级。该接口需要等待升级固件文件成功传给设备端之后再返回，响应时间可能较长。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Device Local Upgrade"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strFilePathName             [IN]            File name"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this API to send the upgrade firmware to the device for upgrade. This API will wait for return until the upgrade firmware is sent to the device, this response may take a long time. \\n"]
    #[doc = "For CameraLink device, it keeps sending upgrade firmware continuously."]
    pub fn MV_CC_LocalUpgrade(
        handle: *mut ::std::os::raw::c_void,
        strFilePathName: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取升级进度"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnProcess                   [OUT]           进度接收地址"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Upgrade Progress"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnProcess                   [OUT]           Progress receiving address"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_GetUpgradeProcess(
        handle: *mut ::std::os::raw::c_void,
        pnProcess: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  读内存"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pBuffer                     [IN][OUT]       作为返回值使用，保存读到的内存值（GEV设备内存值是按照大端模式存储的，其它协议设备按照小端存储）"]
    #[doc = "  @param  nAddress                    [IN]            待读取的内存地址，该地址可以从设备的Camera.xml文件中获取，形如xxx_RegAddr的xml节点值"]
    #[doc = "  @param  nLength                     [IN]            待读取的内存长度"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 访问设备，读取某段寄存器的数据。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Read Memory"]
    #[doc = "  @param  handle                      [IN]            Device Handle"]
    #[doc = "  @param  pBuffer                     [IN][OUT]       Used as a return value, save the read-in memory value ( Memory value is stored in accordance with the big end model)"]
    #[doc = "  @param  nAddress                    [IN]            Memory address to be read, which can be obtained from the Camera.xml file of the device, the form xml node value of xxx_RegAddr"]
    #[doc = "  @param  nLength                     [IN]            Length of the memory to be read"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Access device, read the data from certain register."]
    pub fn MV_CC_ReadMemory(
        handle: *mut ::std::os::raw::c_void,
        pBuffer: *mut ::std::os::raw::c_void,
        nAddress: i64,
        nLength: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  写内存"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pBuffer                     [IN]            待写入的内存值（注意GEV设备内存值要按照大端模式存储，其它协议设备按照小端存储）"]
    #[doc = "  @param  nAddress                    [IN]            待写入的内存地址，该地址可以从设备的Camera.xml文件中获取，形如xxx_RegAddr的xml节点值"]
    #[doc = "  @param  nLength                     [IN]            待写入的内存长度"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 访问设备，把一段数据写入某段寄存器。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Write Memory"]
    #[doc = "  @param  handle                      [IN]            Device Handle"]
    #[doc = "  @param  pBuffer                     [IN]            Memory value to be written ( Note the memory value to be stored in accordance with the big end model)"]
    #[doc = "  @param  nAddress                    [IN]            Memory address to be written, which can be obtained from the Camera.xml file of the device, the form xml node value of xxx_RegAddr"]
    #[doc = "  @param  nLength                     [IN]            Length of the memory to be written"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Access device, write a piece of data into a certain segment of register."]
    pub fn MV_CC_WriteMemory(
        handle: *mut ::std::os::raw::c_void,
        pBuffer: *const ::std::os::raw::c_void,
        nAddress: i64,
        nLength: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  注册异常消息回调，在打开设备之后调用"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  cbException                 [IN]            异常回调函数指针"]
    #[doc = "  @param  pUser                       [IN]            用户自定义变量"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 该接口需要在MV_CC_OpenDevice打开设备之后调用。设备异常断开连接后可以在回调里面获取到异常消息，GigE设备掉线之后需要先调用MV_CC_CloseDevice接口关闭设备，再调用MV_CC_OpenDevice接口重新打开设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Register Exception Message CallBack, call after open device"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  cbException                 [IN]            Exception Message CallBack Function Pointer"]
    #[doc = "  @param  pUser                       [IN]            User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this interface after the device is opened by MV_CC_OpenDevice. When device is exceptionally disconnected, the exception message can be obtained from callback function. For Disconnected GigE device, first call MV_CC_CloseDevice to shut device, and then call MV_CC_OpenDevice to reopen the device."]
    pub fn MV_CC_RegisterExceptionCallBack(
        handle: *mut ::std::os::raw::c_void,
        cbException: ::std::option::Option<
            unsafe extern "C" fn(
                nMsgType: ::std::os::raw::c_uint,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  注册全部事件回调，在打开设备之后调用"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  cbEvent                     [IN]            事件回调函数指针"]
    #[doc = "  @param  pUser                       [IN]            用户自定义变量"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 通过该接口设置事件回调，可以在回调函数里面获取采集、曝光等事件信息。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Register event callback, which is called after the device is opened"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  cbEvent                     [IN]            Event CallBack Function Pointer"]
    #[doc = "  @param  pUser                       [IN]            User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this API to set the event callback function to get the event information, e.g., acquisition, exposure, and so on. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_RegisterAllEventCallBack(
        handle: *mut ::std::os::raw::c_void,
        cbEvent: ::std::option::Option<
            unsafe extern "C" fn(
                pEventInfo: *mut MV_EVENT_OUT_INFO,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  注册单个事件回调，在打开设备之后调用"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strEventName                [IN]            事件名称"]
    #[doc = "  @param  cbEvent                     [IN]            事件回调函数指针"]
    #[doc = "  @param  pUser                       [IN]            用户自定义变量"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 通过该接口设置事件回调，可以在回调函数里面获取采集、曝光等事件信息。\\n"]
    #[doc = "该接口不支持CameraLink设备，仅支持\"设备掉线\"这一种事件。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Register single event callback, which is called after the device is opened"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strEventName                [IN]            Event name"]
    #[doc = "  @param  cbEvent                     [IN]            Event CallBack Function Pointer"]
    #[doc = "  @param  pUser                       [IN]            User defined variable"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this API to set the event callback function to get the event information, e.g., acquisition, exposure, and so on. \\n"]
    #[doc = "This API is not supported by CameraLink device ."]
    pub fn MV_CC_RegisterEventCallBackEx(
        handle: *mut ::std::os::raw::c_void,
        strEventName: *const ::std::os::raw::c_char,
        cbEvent: ::std::option::Option<
            unsafe extern "C" fn(
                pEventInfo: *mut MV_EVENT_OUT_INFO,
                pUser: *mut ::std::os::raw::c_void,
            ),
        >,
        pUser: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  强制IP"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nIP                         [IN]            设置的IP"]
    #[doc = "  @param  nSubNetMask                 [IN]            子网掩码"]
    #[doc = "  @param  nDefaultGateWay             [IN]            默认网关"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 强制设置设备网络参数（包括IP、子网掩码、默认网关），强制设置之后将需要重新创建设备句柄，仅GigEVision设备支持。\\n"]
    #[doc = "如果设备为DHCP的状态，调用该接口强制设置设备网络参数之后设备将会重启。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Force IP"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nIP                         [IN]            IP to set"]
    #[doc = "  @param  nSubNetMask                 [IN]            Subnet mask"]
    #[doc = "  @param  nDefaultGateWay             [IN]            Default gateway"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Force setting camera network parameter (including IP address, subnet mask, default gateway). After forced setting, device handle should be created again. This function is only supported by GigEVision camera.\\n"]
    #[doc = "If device is in DHCP status, after calling this API to force setting camera network parameter, the device will restart."]
    pub fn MV_GIGE_ForceIpEx(
        handle: *mut ::std::os::raw::c_void,
        nIP: ::std::os::raw::c_uint,
        nSubNetMask: ::std::os::raw::c_uint,
        nDefaultGateWay: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  配置IP方式"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nType                       [IN]            IP类型，见MV_IP_CFG_x"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 发送命令设置设备的IP方式，如DHCP、LLA等，仅GigEVision设备支持。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  IP configuration method"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nType                       [IN]            IP type, refer to MV_IP_CFG_x"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Send command to set camera IP mode, such as DHCP and LLA, only supported by GigEVision."]
    pub fn MV_GIGE_SetIpConfig(
        handle: *mut ::std::os::raw::c_void,
        nType: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置仅使用某种模式,type: MV_NET_TRANS_x，不设置时，默认优先使用driver"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nType                       [IN]            网络传输模式，见MV_NET_TRANS_x"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 通过该接口可以设置SDK内部优先使用的网络模式，默认优先使用驱动模式，仅GigEVision设备支持。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set to use only one mode,type: MV_NET_TRANS_x. When do not set, priority is to use driver by default"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nType                       [IN]            Net transmission mode, refer to MV_NET_TRANS_x"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarksSet SDK internal priority network mode through this interface, drive mode by default, only supported by GigEVision camera."]
    pub fn MV_GIGE_SetNetTransMode(
        handle: *mut ::std::os::raw::c_void,
        nType: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取网络传输信息"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstInfo                     [OUT]           信息结构体"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 通过该接口可以获取网络传输相关信息，包括已接收数据大小、丢帧数量等，在MV_CC_StartGrabbing开启采集之后调用。仅GigEVision设备支持。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get net transmission information"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstInfo                     [OUT]           Information Structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Get network transmission information through this API, including received data size, number of lost frames. Call this API after starting image acquiring through MV_CC_StartGrabbing. This API is supported only by GigEVision Camera."]
    pub fn MV_GIGE_GetNetTransInfo(
        handle: *mut ::std::os::raw::c_void,
        pstInfo: *mut MV_NETTRANS_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置枚举命令的回复包类型"]
    #[doc = "  @param  nMode                       [IN]            回复包类型（默认广播），0-单播，1-广播"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口只对GigE相机有效。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Setting the ACK mode of devices Discovery."]
    #[doc = "  @param  nMode                       [IN]            ACK mode（Default-Broadcast）,0-Unicast,1-Broadcast."]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is ONLY effective on GigE cameras. \\n"]
    pub fn MV_GIGE_SetDiscoveryMode(nMode: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置GVSP取流超时时间"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nMillisec                   [IN]            超时时间，默认300ms，范围：>10ms"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 连接设备之后，取流动作发生前，调用该接口可以设置GVSP取流超时时间。GVSP取流超时设置过短可能造成图像异常，设置过长可能造成取流时间变长。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set GVSP streaming timeout"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nMillisec                   [IN]            Timeout, default 300ms, range: >10ms"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, and just before start streaming,"]
    #[doc = "           call this interface to set GVSP streaming timeout value."]
    pub fn MV_GIGE_SetGvspTimeout(
        handle: *mut ::std::os::raw::c_void,
        nMillisec: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取GVSP取流超时时间"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnMillisec                  [OUT]           超时时间指针，以毫秒位单位"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口用于获取当前的GVSP取流超时时间"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get GVSP streaming timeout"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnMillisec                  [OUT]           Timeout, ms as unit"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to get the current GVSP streaming timeout."]
    pub fn MV_GIGE_GetGvspTimeout(
        handle: *mut ::std::os::raw::c_void,
        pnMillisec: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置GVCP命令超时时间"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nMillisec                   [IN]            超时时间，默认500ms，范围：0-10000ms"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 连接设备之后调用该接口可以设置GVCP命令超时时间。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set GVCP cammand timeout"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nMillisec                   [IN]            Timeout, default 500ms, range: 0-10000ms"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After the device is connected, call this interface to set GVCP command timeout time."]
    pub fn MV_GIGE_SetGvcpTimeout(
        handle: *mut ::std::os::raw::c_void,
        nMillisec: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取GVCP命令超时时间"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnMillisec                  [OUT]           超时时间指针，以毫秒位单位"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口用于获取当前的GVCP超时时间。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get GVCP cammand timeout"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnMillisec                  [OUT]           Timeout, ms as unit"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to get the current GVCP timeout."]
    pub fn MV_GIGE_GetGvcpTimeout(
        handle: *mut ::std::os::raw::c_void,
        pnMillisec: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置重传GVCP命令次数"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nRetryGvcpTimes             [IN]            重传次数，范围：0-100"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口用于在GVCP包传输异常时，增加重传的次数，在一定程度上可以避免设备掉线，范围为0-100。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set the number of retry GVCP cammand"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nRetryGvcpTimes             [IN]            The number of retries，rang：0-100"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to increase The Times of retransmission when GVCP packet transmission is abnormal,and to some extent, it can avoid dropping the camera, with a range of 0-100."]
    pub fn MV_GIGE_SetRetryGvcpTimes(
        handle: *mut ::std::os::raw::c_void,
        nRetryGvcpTimes: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取重传GVCP命令次数"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnRetryGvcpTimes            [OUT]           重传次数指针"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口用于获取当前的GVCP重传次数，默认3次。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get the number of retry GVCP cammand"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnRetryGvcpTimes            [OUT]           The number of retries"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to get the current number of GVCP retransmissions, which defaults to 3."]
    pub fn MV_GIGE_GetRetryGvcpTimes(
        handle: *mut ::std::os::raw::c_void,
        pnRetryGvcpTimes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取最佳的packet size，该接口目前只支持GigE设备"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 最佳packetsize"]
    #[doc = "  @remarks 获取最佳的packet size，对应GigEVision设备是SCPS，对应U3V设备是每次从驱动读取的包大小，该大小即网络上传输一个包的大小。该接口需要在MV_CC_OpenDevice之后、MV_CC_StartGrabbing之前调用。 \\n"]
    #[doc = "该接口不支持CameraLink设备。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get the optimal Packet Size, Only support GigE Camera"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Optimal packetsize"]
    #[doc = "  @remarks To get optimized packet size, for GigEVision device is SCPS, for USB3Vision device is the size of packet read from drive each time, and it is the size of a packet transported on the network. The interface should be called after MV_CC_OpenDevice and before MV_CC_StartGrabbing. \\n"]
    #[doc = "This API is not supported by CameraLink device."]
    pub fn MV_CC_GetOptimalPacketSize(handle: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MV_GIGE_SetResend(
        handle: *mut ::std::os::raw::c_void,
        bEnable: ::std::os::raw::c_uint,
        nMaxResendPercent: ::std::os::raw::c_uint,
        nResendTimeout: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置重传命令最大尝试次数"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nRetryTimes                 [IN]            重传命令最大尝试次数，默认20"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口必须在调用MV_GIGE_SetResend开启重传包功能之后调用，否则失败且返回MV_E_CALLORDER"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  set the max resend retry times"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nRetryTimes                 [IN]            The max times to retry resending lost packets，default 20"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface MUST be called after enabling resending lost packets by calling MV_GIGE_SetResend, \\n"]
    #[doc = "           otherwise would fail and return MV_E_CALLORDER."]
    pub fn MV_GIGE_SetResendMaxRetryTimes(
        handle: *mut ::std::os::raw::c_void,
        nRetryTimes: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取重传命令最大尝试次数"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnRetryTimes                [OUT]           重传命令最大尝试次数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口必须在调用MV_GIGE_SetResend开启重传包功能之后调用，否则失败且返回MV_E_CALLORDER"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  get the max resend retry times"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnRetryTimes                [OUT]           The max times to retry resending lost packets"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface MUST be called after enabling resending lost packets by calling MV_GIGE_SetResend, \\n"]
    #[doc = "           otherwise would fail and return MV_E_CALLORDER."]
    pub fn MV_GIGE_GetResendMaxRetryTimes(
        handle: *mut ::std::os::raw::c_void,
        pnRetryTimes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置同一重传包多次请求之间的时间间隔"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nMillisec                   [IN]            同一重传包多次请求之间的时间间隔，默认10ms"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口必须在调用MV_GIGE_SetResend开启重传包功能之后调用，否则失败且返回MV_E_CALLORDER"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  set time interval between same resend requests"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nMillisec                   [IN]            The time interval between same resend requests,default 10ms"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface MUST be called after enabling resending lost packets by calling MV_GIGE_SetResend, \\n"]
    #[doc = "           otherwise would fail and return MV_E_CALLORDER."]
    pub fn MV_GIGE_SetResendTimeInterval(
        handle: *mut ::std::os::raw::c_void,
        nMillisec: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取同一重传包多次请求之间的时间间隔"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnMillisec                  [OUT]           同一重传包多次请求之间的时间间隔"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口必须在调用MV_GIGE_SetResend开启重传包功能之后调用，否则失败且返回MV_E_CALLORDER"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  get time interval between same resend requests"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnMillisec                  [OUT]           The time interval between same resend requests"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface MUST be called after enabling resending lost packets by calling MV_GIGE_SetResend, \\n"]
    #[doc = "           otherwise would fail and return MV_E_CALLORDER."]
    pub fn MV_GIGE_GetResendTimeInterval(
        handle: *mut ::std::os::raw::c_void,
        pnMillisec: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置传输模式，可以为单播模式、组播模式等"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  stTransmissionType          [IN]            传输模式结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过该接口可以设置传输模式为单播、组播等模式，仅GigEVision设备支持。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set transmission type,Unicast or Multicast"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  stTransmissionType          [IN]            Struct of transmission type"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Call this API to set the transmission mode as single cast mode and multicast mode. And this API is only valid for GigEVision camera."]
    pub fn MV_GIGE_SetTransmissionType(
        handle: *mut ::std::os::raw::c_void,
        pstTransmissionType: *mut MV_TRANSMISSION_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief   发出动作命令"]
    #[doc = "  @param   pstActionCmdInfo           [IN]            动作命令信息"]
    #[doc = "  @param   pstActionCmdResults        [OUT]           动作命令返回信息列表"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 仅GigEVision设备支持。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Issue Action Command"]
    #[doc = "  @param   pstActionCmdInfo           [IN]            Action Command"]
    #[doc = "  @param   pstActionCmdResults        [OUT]           Action Command Result List"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is supported only by GigEVision camera."]
    pub fn MV_GIGE_IssueActionCommand(
        pstActionCmdInfo: *mut MV_ACTION_CMD_INFO,
        pstActionCmdResults: *mut MV_ACTION_CMD_RESULT_LIST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取组播状态"]
    #[doc = "  @param  pstDevInfo                  [IN]            设备信息结构体"]
    #[doc = "  @param  pbStatus                    [OUT]           组播状态,true:组播状态，false:非组播"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口用于判断设备当前是否处于组播状态，解决客户端枚举时需要打开设备判断组播的问题。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Multicast Status"]
    #[doc = "  @param  pstDevInfo                  [IN]            Device Information Structure"]
    #[doc = "  @param  pbStatus                    [OUT]           Status of Multicast"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to determine whether the camera is currently in multicast state, and to solve the problem that the client needs to turn on the camera to determine multicast when enumerating."]
    pub fn MV_GIGE_GetMulticastStatus(
        pstDevInfo: *mut MV_CC_DEVICE_INFO,
        pbStatus: *mut bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置设备波特率"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nBaudrate                   [IN]            设置的波特率值，数值参考CameraParams.h中宏定义，如#define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 该接口支持在设备未连接时调用。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set device baudrate using one of the CL_BAUDRATE_XXXX value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nBaudrate                   [IN]            baud rate to set. Refer to the 'CameraParams.h' for parameter definitions, for example, #define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is supported only by CameraLink device.\\n"]
    #[doc = "This API support calls when devices are not connected."]
    pub fn MV_CAML_SetDeviceBaudrate(
        handle: *mut ::std::os::raw::c_void,
        nBaudrate: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取设备波特率"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnCurrentBaudrate           [OUT]           波特率信息指针，数值参考CameraParams.h中宏定义，如#define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 该接口支持在设备未连接时调用。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Returns the current device baudrate, using one of the CL_BAUDRATE_XXXX value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnCurrentBaudrate           [OUT]           Return pointer of baud rate to user. Refer to the 'CameraParams.h' for parameter definitions, for example, #define MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is supported only by CameraLink device.\\n"]
    #[doc = "This API support calls when devices are not connected."]
    pub fn MV_CAML_GetDeviceBaudrate(
        handle: *mut ::std::os::raw::c_void,
        pnCurrentBaudrate: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取设备与主机间连接支持的波特率"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnBaudrateAblity            [OUT]           支持的波特率信息的指针。所支持波特率的或运算结果，单个数值参考CameraParams.h中宏定义，如MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 该接口支持在设备未连接时调用。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Returns supported baudrates of the combined device and host interface"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnBaudrateAblity            [OUT]           Return pointer of the supported baudrates to user. 'OR' operation results of the supported baudrates. Refer to the 'CameraParams.h' for single value definitions, for example, MV_CAML_BAUDRATE_9600  0x00000001"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is supported only by CameraLink device.\\n"]
    #[doc = "This API support calls when devices are not connected."]
    pub fn MV_CAML_GetSupportBaudrates(
        handle: *mut ::std::os::raw::c_void,
        pnBaudrateAblity: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置串口操作等待时长"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nMillisec                   [IN]            串口操作的等待时长, 单位为ms"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Sets the timeout for operations on the serial port"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nMillisec                   [IN]            Timeout in [ms] for operations on the serial port."]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CAML_SetGenCPTimeOut(
        handle: *mut ::std::os::raw::c_void,
        nMillisec: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置U3V的传输包大小"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nTransferSize               [IN]            传输的包大小, Byte，默认为1M，rang：>=0x10000"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 增加传输包大小可以适当降低取流时的CPU占用率。但不同的PC和不同USB扩展卡存在不同的兼容性，如果该参数设置过大可能会出现取不到图像的风险。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set transfer size of U3V device"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nTransferSize               [IN]            Transfer size，Byte，default：1M，rang：>=0x10000"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Increasing the transmission packet size can reduce the CPU utilization at the time of fetching. However, different PCS and different USB extension CARDS have different compatibility, and if this parameter is set too large, there may be the risk of not getting the image."]
    pub fn MV_USB_SetTransferSize(
        handle: *mut ::std::os::raw::c_void,
        nTransferSize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取U3V的传输包大小"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnTransferSize              [OUT]           传输的包大小指针, Byte"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 该接口用于获取当前的U3V传输包大小，默认1M。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get transfer size of U3V device"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnTransferSize              [OUT]           Transfer size，Byte"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to get the current U3V transfer packet size, default 1M."]
    pub fn MV_USB_GetTransferSize(
        handle: *mut ::std::os::raw::c_void,
        pnTransferSize: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置U3V的传输通道个数"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nTransferWays               [IN]            传输通道个数，范围：1-10"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 用户可以根据PC的性能、设备出图帧率、图像大小和内存使用率等因素对该参数进行调节。但不同的PC和不同的USB扩展卡存在不同的兼容性。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set transfer ways of U3V device"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nTransferWays               [IN]            Transfer ways，rang：1-10"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Users can adjust this parameter according to PC performance, camera image frame rate, image size, memory utilization and other factors. But different PCS and different USB expansion CARDS have different compatibility."]
    pub fn MV_USB_SetTransferWays(
        handle: *mut ::std::os::raw::c_void,
        nTransferWays: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取U3V的传输通道个数"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pnTransferWays              [OUT]           传输通道个数指针"]
    #[doc = "  @return 成功,返回MV_OK,失败,返回错误码"]
    #[doc = "  @remarks 该接口用于获取当前的U3V异步取流节点个数，2000W设备的MONO8默认为3个，YUV为默认2个，RGB为默认1个，其它情况默认8个节点。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get transfer ways of U3V device"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pnTransferWays              [OUT]           Transfer ways"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This interface is used to get the current number of U3V asynchronous feed nodes. For 2000W camera, MONO8 defaults to 3, YUV defaults to 2, RGB defaults to 1, and other cases default to 8 nodes."]
    pub fn MV_USB_GetTransferWays(
        handle: *mut ::std::os::raw::c_void,
        pnTransferWays: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  通过GenTL枚举Interfaces"]
    #[doc = "  @param  pstIFList                   [OUT]           Interfaces列表"]
    #[doc = "  @param  strGenTLPath                [IN]            GenTL的cti文件路径"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks Interfaces列表的内存是在SDK内部分配的，多线程调用该接口时会进行设备列表内存的释放和申请，\\n"]
    #[doc = "建议尽量避免多线程枚举操作。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Enumerate Interfaces with GenTL"]
    #[doc = "  @param  pstIFList                   [OUT]           Interfaces List"]
    #[doc = "  @param  strGenTLPath                [IN]            GenTL cti file path"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks The memory of the Interfaces list is allocated within the SDK. When the interface is invoked by multiple threads, the memory of the device list will be released and applied.\\n"]
    #[doc = "It is recommended to avoid multithreaded enumeration operations as much as possible."]
    pub fn MV_CC_EnumInterfacesByGenTL(
        pstIFList: *mut MV_GENTL_IF_INFO_LIST,
        strGenTLPath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  通过GenTL Interface枚举设备"]
    #[doc = "  @param  pstIFInfo                   [IN]            Interface信息"]
    #[doc = "  @param  pstDevList                  [OUT]           设备列表"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设备列表的内存是在SDK内部分配的，多线程调用该接口时会进行设备列表内存的释放和申请，\\n"]
    #[doc = "建议尽量避免多线程枚举操作。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Enumerate Devices with GenTL interface"]
    #[doc = "  @param  pstIFInfo                   [IN]            Interface information"]
    #[doc = "  @param  pstDevList                  [OUT]           Device List"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks The memory of the list is allocated within the SDK. When the interface is invoked by multiple threads, the memory of the device list will be released and applied.\\n"]
    #[doc = "It is recommended to avoid multithreaded enumeration operations as much as possible."]
    pub fn MV_CC_EnumDevicesByGenTL(
        pstIFInfo: *mut MV_GENTL_IF_INFO,
        pstDevList: *mut MV_GENTL_DEV_INFO_LIST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  卸载cti库"]
    #[doc = "  @param  pGenTLPath                [IN]            枚举卡时加载的cti文件路径"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 卸载前需要保证通过该cti枚举出的相机已全部关闭，否则报错前置条件错误。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Unload cti library"]
    #[doc = "  @param  pGenTLPath                [IN]            GenTL cti file path"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Make sure that all devices enumerated by this cti are already closed."]
    pub fn MV_CC_UnloadGenTLLibrary(
        pGenTLPath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  通过GenTL设备信息创建设备句柄"]
    #[doc = "  @param  handle                      [OUT]           设备句柄"]
    #[doc = "  @param  pstDevInfo                  [IN]            设备信息结构体指针"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 根据输入的设备信息，创建库内部必须的资源和初始化内部模块。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Create Device Handle with GenTL Device Info"]
    #[doc = "  @param  handle                      [OUT]           Device handle"]
    #[doc = "  @param  pstDevInfo                  [IN]            Device Information"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Create required resources within library and initialize internal module according to input device information."]
    pub fn MV_CC_CreateHandleByGenTL(
        handle: *mut *mut ::std::os::raw::c_void,
        pstDevInfo: *const MV_GENTL_DEV_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取设备属性树XML"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pData                       [OUT]           XML数据接收缓存"]
    #[doc = "  @param  nDataSize                   [IN]            接收缓存大小"]
    #[doc = "  @param  pnDataLen                   [OUT]           实际数据大小"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 当pData为NULL或nDataSize比实际的xml文件小时，不拷贝数据，由pnDataLen返回xml文件大小；\\n"]
    #[doc = "当pData为有效缓存地址，且缓存足够大时，拷贝完整数据保存在该缓存里面，并由pnDataLen返回xml文件实际大小。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get camera feature tree XML"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pData                       [OUT]           XML data receiving buffer"]
    #[doc = "  @param  nDataSize                   [IN]            Buffer size"]
    #[doc = "  @param  pnDataLen                   [OUT]           Actual data length"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks When pData is NULL or nDataSize than the actual XML file hours, do not copy the data, returned by pnDataLen XML file size.\\n"]
    #[doc = "When pData is a valid cache address and the cache is large enough, copy the full data into the cache, and pnDataLen returns the actual size of the XML file."]
    pub fn MV_XML_GetGenICamXML(
        handle: *mut ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_uchar,
        nDataSize: ::std::os::raw::c_uint,
        pnDataLen: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获得当前节点的访问模式"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strName                     [IN]            节点名称"]
    #[doc = "  @param  penAccessMode               [OUT]           节点的访问模式"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Access mode of cur node"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strName                     [IN]            Name of node"]
    #[doc = "  @param  penAccessMode               [OUT]           Access mode of the node"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_XML_GetNodeAccessMode(
        handle: *mut ::std::os::raw::c_void,
        strName: *const ::std::os::raw::c_char,
        penAccessMode: *mut MV_XML_AccessMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获得当前节点的类型"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strName                     [IN]            节点名称"]
    #[doc = "  @param  penInterfaceType            [OUT]           节点的类型"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口可以在调用万能接口之前，提前知道节点类型，方便用户选择合适的万能接口进行节点值的设置和获取。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get Interface Type of cur node"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strName                     [IN]            Name of node"]
    #[doc = "  @param  penInterfaceType            [OUT]           Interface Type of the node"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks The interface can know the node type in advance before calling the universal interface, so as to facilitate users to select the appropriate universal interface for setting and obtaining the node value."]
    pub fn MV_XML_GetNodeInterfaceType(
        handle: *mut ::std::os::raw::c_void,
        strName: *const ::std::os::raw::c_char,
        penInterfaceType: *mut MV_XML_InterfaceType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  保存图片，支持Bmp和Jpeg."]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstSaveParam                [IN][OUT]       保存图片参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过将接口可以将从设备采集到的原始图像数据转换成JPEG或者BMP等格式并存放在指定内存中，然后用户可以将转换之后的数据直接保存成图片文件。该接口调用无接口顺序要求，有图像源数据就可以进行转换，可以先调用MV_CC_GetOneFrameTimeout或者MV_CC_RegisterImageCallBackEx设置回调函数，获取一帧图像数据，然后再通过该接口转换格式。 \\n"]
    #[doc = "MV_CC_SaveImageEx2比MV_CC_SaveImageEx增加参数handle，为了保证与其他接口的统一。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Save image, support Bmp and Jpeg."]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstSaveParam                [IN][OUT]       Save image parameters structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Once there is image data, you can call this API to convert the data. \\n"]
    #[doc = "You can also call MV_CC_GetOneFrameTimeout or MV_CC_RegisterImageCallBackEx or MV_CC_GetImageBuffer to get one image frame and set the callback function, and then call this API to convert the format. \\n"]
    #[doc = "Comparing with the API MV_CC_SaveImageEx, this API added the parameter handle to ensure the unity with other API."]
    pub fn MV_CC_SaveImageEx2(
        handle: *mut ::std::os::raw::c_void,
        pstSaveParam: *mut MV_SAVE_IMAGE_PARAM_EX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  保存图像到文件"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstSaveFileParam            [IN][OUT]       保存图片文件参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口支持BMP/JPEG/PNG/TIFF。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Save the image file."]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstSaveFileParam            [IN][OUT]       Save the image file parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API support BMP/JPEG/PNG/TIFF."]
    pub fn MV_CC_SaveImageToFile(
        handle: *mut ::std::os::raw::c_void,
        pstSaveFileParam: *mut MV_SAVE_IMG_TO_FILE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  保存3D点云数据，支持PLY、CSV和OBJ三种格式"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstPointDataParam           [IN][OUT]       保存点云数据参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 3D数据格式保存成3D文件格式，支持PLY/CSV/OBJ，/n"]
    #[doc = "目前支持PixelType_Gvsp_Coord3D_ABC32、PixelType_Gvsp_Coord3D_ABC32f、PixelType_Gvsp_Coord3D_AB32、PixelType_Gvsp_Coord3D_AB32f、PixelType_Gvsp_Coord3D_AC32、PixelType_Gvsp_Coord3D_AC32f,暂不支持其他3D格式。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Save 3D point data, support PLY、CSV and OBJ"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstPointDataParam           [IN][OUT]       Save 3D point data parameters structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Save the 3D data format to 3D file format，support PLY、CSV and OBJ，/n"]
    #[doc = "only support PixelType_Gvsp_Coord3D_ABC32、PixelType_Gvsp_Coord3D_ABC32f、PixelType_Gvsp_Coord3D_AB32、PixelType_Gvsp_Coord3D_AB32f、PixelType_Gvsp_Coord3D_AC32、PixelType_Gvsp_Coord3D_AC32f,Other 3D format is not supported now."]
    pub fn MV_CC_SavePointCloudData(
        handle: *mut ::std::os::raw::c_void,
        pstPointDataParam: *mut MV_SAVE_POINT_CLOUD_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  图像旋转"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstRotateParam              [IN][OUT]       图像旋转参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口只支持MONO8/RGB24/BGR24格式数据的90/180/270度旋转。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Rotate Image"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstRotateParam              [IN][OUT]       Rotate image parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API only support 90/180/270 rotation of data in the MONO8/RGB24/BGR24 format."]
    pub fn MV_CC_RotateImage(
        handle: *mut ::std::os::raw::c_void,
        pstRotateParam: *mut MV_CC_ROTATE_IMAGE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  图像翻转"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstFlipParam                [IN][OUT]       图像翻转参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 该接口只支持MONO8/RGB24/BGR24格式数据的垂直和水平翻转。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Flip Image"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstFlipParam                [IN][OUT]       Flip image parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API only support vertical and horizontal reverse of data in the MONO8/RGB24/BGR24 format."]
    pub fn MV_CC_FlipImage(
        handle: *mut ::std::os::raw::c_void,
        pstFlipParam: *mut MV_CC_FLIP_IMAGE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  像素格式转换"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstCvtParam                 [IN][OUT]       像素格式转换参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 通过将接口可以将从设备采集到的原始图像数据转换成用户所需的像素格式并存放在指定内存中。该接口调用无接口顺序要求，有图像源数据就可以进行转换，可以先调用MV_CC_GetOneFrameTimeout或者MV_CC_RegisterImageCallBackEx设置回调函数，获取一帧图像数据，然后再通过该接口转换格式。如果设备当前采集图像是JPEG压缩的格式，则不支持调用该接口进行转换。 \\n"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Pixel format conversion"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstCvtParam                 [IN][OUT]       Convert Pixel Type parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks This API is used to transform the collected original data to pixel format and save to specified memory. There is no order requirement to call this API, the transformation will execute when there is image data. First call MV_CC_GetOneFrameTimeout or MV_CC_RegisterImageCallBackEx to set callback function, and get a frame of image data, then call this API to transform the format. \\n"]
    pub fn MV_CC_ConvertPixelType(
        handle: *mut ::std::os::raw::c_void,
        pstCvtParam: *mut MV_CC_PIXEL_CONVERT_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置插值算法类型"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  nBayerCvtQuality            [IN]            Bayer的插值方法  0-快速 1-均衡 2-最优（默认为最优）"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设置内部图像转换接口的Bayer插值算法类型参数，MV_CC_ConvertPixelType、MV_CC_GetImageForRGB/BGR接口内部使用的插值算法是该接口所设定的。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Interpolation algorithm type setting"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  nBayerCvtQuality            [IN]            Bayer interpolation method  0-Fast 1-Equilibrium 2-Optimal"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Set the bell interpolation quality parameters of the internal image conversion interface, and the interpolation algorithm used in the MV_CC_ConvertPixelType and MV_CC_GetImageForRGB/BGR interfaces is set by this interface."]
    pub fn MV_CC_SetBayerCvtQuality(
        handle: *mut ::std::os::raw::c_void,
        nBayerCvtQuality: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Bayer格式的Gamma值"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  fBayerGammaValue            [IN]            Gamma值[0.1,4.0]"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设置该值后，在调用MV_CC_ConvertPixelType、MV_CC_SaveImageEx2接口将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Gamma value"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  fBayerGammaValue            [IN]            Gamma value[0.1,4.0]"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After setting the value, it work in the calling MV_CC_ConvertPixelType\\MV_CC_SaveImageEx2 API convert Bayer8/10/12/16 to RGB24/48， RGBA32/64，BGR24/48，BGRA32/64."]
    pub fn MV_CC_SetBayerGammaValue(
        handle: *mut ::std::os::raw::c_void,
        fBayerGammaValue: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Bayer格式的Gamma信息"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstGammaParam               [IN]            Gamma信息"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 设置该信息后，在调用MV_CC_ConvertPixelType、MV_CC_SaveImageEx2接口将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set Gamma param"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstGammaParam               [IN]            Gamma param"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After setting the param, it work in the calling MV_CC_ConvertPixelType\\MV_CC_SaveImageEx2 API convert Bayer8/10/12/16 to RGB24/48， RGBA32/64，BGR24/48，BGRA32/64."]
    pub fn MV_CC_SetBayerGammaParam(
        handle: *mut ::std::os::raw::c_void,
        pstGammaParam: *mut MV_CC_GAMMA_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Bayer格式的CCM使能和矩阵，量化系数默认1024"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstCCMParam                 [IN]            CCM参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 开启CCM并设置CCM矩阵后，在调用MV_CC_ConvertPixelType、MV_CC_SaveImageEx2接口将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set CCM param,Scale default 1024"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstCCMParam                 [IN]            CCM parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After enable the color correction and set the color correction matrix, It work in the calling MV_CC_ConvertPixelType\\MV_CC_SaveImageEx2 API convert Bayer8/10/12/16 to RGB24/48， RGBA32/64，BGR24/48，BGRA32/64."]
    pub fn MV_CC_SetBayerCCMParam(
        handle: *mut ::std::os::raw::c_void,
        pstCCMParam: *mut MV_CC_CCM_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  设置Bayer格式的CCM使能和矩阵"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstCCMParam                 [IN]            CCM参数"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 开启CCM并设置CCM矩阵后，在调用MV_CC_ConvertPixelType、MV_CC_SaveImageEx2接口将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Set CCM param"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstCCMParam                 [IN]            CCM parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks After enable the color correction and set the color correction matrix, It work in the calling MV_CC_ConvertPixelType\\MV_CC_SaveImageEx2 API convert Bayer8/10/12/16 to RGB24/48， RGBA32/64，BGR24/48，BGRA32/64."]
    pub fn MV_CC_SetBayerCCMParamEx(
        handle: *mut ::std::os::raw::c_void,
        pstCCMParam: *mut MV_CC_CCM_PARAM_EX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  无损解码"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstDecodeParam              [IN][OUT]       无损解码参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = "  @remarks 将从相机中取到的无损压缩码流解码成裸数据，同时支持解析当前相机实时图像的水印信息（如果输入的无损码流不是当前相机或者不是实时取流的，则水印解析可能异常）"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  High Bandwidth Decode"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstDecodeParam              [IN][OUT]       High Bandwidth Decode parameter structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    #[doc = "  @remarks Decode the lossless compressed data from the camera into raw data"]
    pub fn MV_CC_HB_Decode(
        handle: *mut ::std::os::raw::c_void,
        pstDecodeParam: *mut MV_CC_HB_DECODE_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  保存设备属性"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strFileName                 [IN]            属性文件名"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Save camera feature"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strFileName                 [IN]            File name"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_FeatureSave(
        handle: *mut ::std::os::raw::c_void,
        strFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  导入设备属性"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  strFileName                 [IN]            属性文件名"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Load camera feature"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  strFileName                 [IN]            File name"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_FeatureLoad(
        handle: *mut ::std::os::raw::c_void,
        strFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  从设备读取文件"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstFileAccess               [IN]            文件存取结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Read the file from the camera"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstFileAccess               [IN]            File access structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_FileAccessRead(
        handle: *mut ::std::os::raw::c_void,
        pstFileAccess: *mut MV_CC_FILE_ACCESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  将文件写入设备"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstFileAccess               [IN]            文件存取结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Write the file to camera"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstFileAccess               [IN]            File access structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_FileAccessWrite(
        handle: *mut ::std::os::raw::c_void,
        pstFileAccess: *mut MV_CC_FILE_ACCESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  获取文件存取的进度"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstFileAccessProgress       [IN]            进度内容"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码 （当前文件存取的状态）"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Get File Access Progress"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstFileAccessProgress       [IN]            File access Progress"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_GetFileAccessProgress(
        handle: *mut ::std::os::raw::c_void,
        pstFileAccessProgress: *mut MV_CC_FILE_ACCESS_PROGRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  开始录像"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstRecordParam              [IN]            录像参数结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Start Record"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstRecordParam              [IN]            Record param structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_StartRecord(
        handle: *mut ::std::os::raw::c_void,
        pstRecordParam: *mut MV_CC_RECORD_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  输入录像数据"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @param  pstInputFrameInfo           [IN]            录像数据结构体"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Input RAW data to Record"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @param  pstInputFrameInfo           [IN]            Record data structure"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_InputOneFrame(
        handle: *mut ::std::os::raw::c_void,
        pstInputFrameInfo: *mut MV_CC_INPUT_FRAME_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @~chinese"]
    #[doc = "  @brief  停止录像"]
    #[doc = "  @param  handle                      [IN]            设备句柄"]
    #[doc = "  @return 成功，返回MV_OK；错误，返回错误码"]
    #[doc = ""]
    #[doc = "  @~english"]
    #[doc = "  @brief  Stop Record"]
    #[doc = "  @param  handle                      [IN]            Device handle"]
    #[doc = "  @return Success, return MV_OK. Failure, return error code"]
    pub fn MV_CC_StopRecord(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
